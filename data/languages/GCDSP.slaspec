# sleigh specification file for GameCube DSP

# Adjust the formatting of BLOOP/BLOOPI; see Addr16After below
@define BLOOP_ONE_AFTER
# Directly mutate the sr register instead of a set of fake registers
# The fake registers provide better decompilation
#@define USE_REAL_SR_REGISTER
# Simplify decompilation of the left+right shift instructions
@define SIMPLIFY_SHIFTS
# Assume CR is always set to 0x00ff - makes LRS and SRS disassemble better
# This assumption is violated for Zelda uCode.
@define SIMPLIFY_CR
# Apply sign-extension to writes to $ac0.m and $ac1.m when the processor says it should happen
# When disabled, 16-bit mode is always assumed.
@define USE_40_BIT_SIGN_EXTENSION
# Always apply sign-extension (needs the above to be not be defined)
# This gets rid of a check on SR_40_MODE, which results in cleaner code,
# but the results will be incorrect.
#@define ALWAYS_USE_40_BIT_SIGN_EXTENSION
# Apply saturation to reads from $ac0.m and $ac1.m when the processor says it should happen
# When disabled, 16-bit mode is always assumed. Enabling results in much messier code.
#@define USE_40_BIT_SATURATION

define endian=big;
define alignment=2;

define space inst     type=ram_space      size=2 wordsize=2;
define space data     type=ram_space      size=2 wordsize=2 default;
define space register type=register_space size=1 wordsize=2;

define register offset=0x00 size=2 [ ar0 ar1 ar2 ar3 ]; # Addressing registers
define register offset=0x08 size=2 [ ix0 ix1 ix2 ix3 ]; # Indexing registers
define register offset=0x10 size=2 [ wr0 wr1 wr2 wr3 ]; # Wrapping registers
define register offset=0x18 size=2 [ st0 st1 st2 st3 ]; # Stack-related registers
#define register offset=0x20 size=2 [ ac0.h ac1.h ]; # 40-bit accumulators
define register offset=0x24 size=2 [ cr sr ];
define register offset=0x28 size=2 [ prod.l prod.m1 prod.h prod.m2 ]; # Product
#define register offset=0x30 size=2 [ ax0.l ax1.l ax0.h ax1.h ]; # 32-bit accumulators
#define register offset=0x38 size=2 [ ac0.l ac1.l ac0.m ac1.m ]; # 40-bit accumulators

# Fake versions of the accumulator registers to make emulating them reasonable
define register offset=0x80 size=2 [ ac0.h ac0.m ac0.l ];
define register offset=0x81 size=1 [ ac0.hreal ];
define register offset=0x81 size=5 [ ac0 ];
define register offset=0x81 size=3 [ acs0 ]; # Short/mid accumulator, 24 bits
define register offset=0x90 size=2 [ ac1.h ac1.m ac1.l ];
define register offset=0x91 size=1 [ ac1.hreal ];
define register offset=0x91 size=5 [ ac1 ];
define register offset=0x91 size=3 [ acs1 ]; # Short/mid accumulator, 24 bits
define register offset=0xA0 size=2 [ ax0.h ax0.l ];
define register offset=0xA0 size=4 [ ax0 ];
define register offset=0xB0 size=2 [ ax1.h ax1.l ];
define register offset=0xB0 size=4 [ ax1 ];
define register offset=0xC1 size=5 [ prod ];

# Fake register for extra-fake purposes; hardware uses some of the stacks for this
define register offset=0xF0 size=8 [ loopcontext ];

# Magic to make loops work
define context loopcontext
	loopskipaddr = (0,15) noflow
	hasloopcheck = (16,16) noflow
	loopjumpbackaddr = (32,47) noflow
	hasloopjumpback = (48,48) noflow
;

# Regular and hacky implementation of status register
@ifdef USE_REAL_SR_REGISTER
@define SR_CARRY            "sr[0,1]"
@define SR_OVERFLOW         "sr[1,1]"
@define SR_ARITH_ZERO       "sr[2,1]"
@define SR_SIGN             "sr[3,1]"
@define SR_OVER_32          "sr[4,1]"
@define SR_TOP2BITS         "sr[5,1]"
@define SR_LOGIC_ZERO       "sr[6,1]"
@define SR_OVERFLOW_STICKY  "sr[7,1]"
@define SR_100              "sr[8,1]"
@define SR_INT_ENABLE       "sr[9,1]"
@define SR_400              "sr[10,1]"
@define SR_EXT_INT_ENABLE   "sr[11,1]"
@define SR_1000             "sr[12,1]"
@define SR_MUL_MODIFY       "sr[13,1]"
@define SR_40_MODE          "sr[14,1]"
@define SR_MUL_UNSIGNED     "sr[15,1]"
@else
define space hack_register type=ram_space size=1;
define hack_register offset=0 size=1 [ SR_CARRY_ SR_OVERFLOW_ SR_ARITH_ZERO_ SR_SIGN_ SR_OVER_32_ SR_TOP2BITS_ SR_LOGIC_ZERO_ SR_OVERFLOW_STICKY_ SR_100_ SR_INT_ENABLE_ SR_400_ SR_EXT_INT_ENABLE_ SR_1000_ SR_MUL_MODIFY_ SR_40_MODE_ SR_MUL_UNSIGNED_ ];
# Note: forcing to only a single bit.  Also, we need to use macros in both cases for consistent syntax.
@define SR_CARRY "SR_CARRY_[0,1]"
@define SR_OVERFLOW "SR_OVERFLOW_[0,1]"
@define SR_ARITH_ZERO "SR_ARITH_ZERO_[0,1]"
@define SR_SIGN "SR_SIGN_[0,1]"
@define SR_OVER_32 "SR_OVER_32_[0,1]"
@define SR_TOP2BITS "SR_TOP2BITS_[0,1]"
@define SR_LOGIC_ZERO "SR_LOGIC_ZERO_[0,1]"
@define SR_OVERFLOW_STICKY "SR_OVERFLOW_STICKY_[0,1]"
@define SR_100 "SR_100_[0,1]"
@define SR_INT_ENABLE "SR_INT_ENABLE_[0,1]"
@define SR_400 "SR_400_[0,1]"
@define SR_EXT_INT_ENABLE "SR_EXT_INT_ENABLE_[0,1]"
@define SR_1000 "SR_1000_[0,1]"
@define SR_MUL_MODIFY "SR_MUL_MODIFY_[0,1]"
@define SR_40_MODE "SR_40_MODE_[0,1]"
@define SR_MUL_UNSIGNED "SR_MUL_UNSIGNED_[0,1]"
@endif

define token opbyte (16)
	op0_4  = (0, 3)
	op3_8  = (3, 7)
	op4_8  = (4, 7)
	op5_8  = (5, 7)
	op6_8  = (6, 7)
	op7_9  = (7, 8)
	op8_16 = (8, 15)
	op9_16 = (9, 15)
	op10_16 = (10, 15)
	op11_16 = (11, 15)

	op0_5 = (0, 4)
	op5   = (4, 4)

	ar0_2 = (0, 1)
	ix0_2 = (0, 1)

	ix2_4 = (2, 3)
	op2_4 = (2, 3)

	reg0_5 = (0, 4)

	ar5_7 = (5, 6)
	ix5_7 = (5, 6)

	reg5_8 = (5, 7)
	reg5_10 = (5, 9)

	cc0_4 = (0, 3)

	acm8 = (8, 8)
	acf8 = (8, 8)
	acs8 = (8, 8)
	ac8_11 = (8, 10)
	ac8_10 = (8, 9)
	ach8display = (8, 8)
	ach8 = (8, 8)

	srbit = (0, 2)
	imm6 = (0, 5)

	imm8 = (0, 7)
	simm8 = (0, 7) signed
;

# Note that if *[const]:2 is not used to use the value as a pointer in the constant address space, things break and the value will be treated as 0.
# i.e. with just { export imm8; } setting a register to Imm8 apepars to set it to 0, while setting it to imm8 works fine.
# There is a warning for this, though it's not obvious: "Table 'Imm8' exports size 0".
Imm6: "#"^imm6 is imm6 { export *[const]:2 imm6; }
# See comment by LSR
Imm6Right: "#"^rightshiftvalue is imm6=0 [ rightshiftvalue = 0; ] { export *[const]:2 rightshiftvalue; }
Imm6Right: "#"^rightshiftvalue is imm6 [ rightshiftvalue = (64 - imm6); ] { export *[const]:2 rightshiftvalue; }

Imm8: "#"^imm8 is imm8 { export *[const]:2 imm8; }
SImm8: "#"^simm8 is simm8 { export *[const]:2 simm8; }
Mem8FF: "@"^addr is imm8 [ addr = 0xff00 | imm8; ] { export *:2 addr; }
@ifdef SIMPLIFY_CR
Mem8CR: Mem8FF is Mem8FF { export Mem8FF; }
@else
Mem8CR: "@((cr << 8) | "^imm8^")" is imm8 { addr:2 = (((cr & 0xff) << 8) | imm8); export *:2 addr; }
@endif

define token data16 (16)
	imm16  = (0,15)
	simm16 = (0,15) signed
;

Addr16: imm16 is imm16 { export *[inst]:1 imm16; }
@ifdef BLOOP_ONE_AFTER
# Formatting convenience: add 1 to the address for BLOOP/BLOOPI, to point to the address after the loop
# instead of the one in the loop.  This puts a label after the loop instead of inside of the loop.
# (This is mainly needed because Ghidra generates the label off of the operand, not the actual jump location.
# Even with this, BLOOP generates a _read_ reference instead of a jump reference, for some reason)
Addr16After: dest is imm16 [ dest = imm16 + 1; ] { export *[inst]:1 dest; }
@endif
Imm16: "#"^imm16 is imm16 { export *[const]:2 imm16; }
SImm16: "#"^simm16 is simm16 { export *[const]:2 simm16; }
Mem16: "@"^imm16 is imm16 { export *:2 imm16; }

attach variables [ reg0_5 reg5_10 ] [
	ar0 ar1 ar2 ar3
	ix0 ix1 ix2 ix3
	wr0 wr1 wr2 wr3
	st0 st1 st2 st3
	ac0.h ac1.h
	cr sr
	prod.l prod.m1 prod.h prod.m2
	ax0.l ax1.l ax0.h ax1.h
	ac0.l ac1.l ac0.m ac1.m
];

macro SIGN_EXTEND_AC0M() {
@ifdef USE_40_BIT_SIGN_EXTENSION
@ifndef ALWAYS_USE_40_BIT_SIGN_EXTENSION
	if (!$(SR_40_MODE)) goto <done>;
@endif
	ac0 = sext(ac0.m) << 16;
@ifndef ALWAYS_USE_40_BIT_SIGN_EXTENSION
	<done>
@endif
@endif
}
macro SIGN_EXTEND_AC1M() {
@ifdef USE_40_BIT_SIGN_EXTENSION
@ifndef ALWAYS_USE_40_BIT_SIGN_EXTENSION
	if (!$(SR_40_MODE)) goto <done>;
@endif
	ac1 = sext(ac1.m) << 16;
@ifndef ALWAYS_USE_40_BIT_SIGN_EXTENSION
	<done>
@endif
@endif
}

# According to 7.9. P-code Macros:
# Parameters are passed by reference, so the value of varnodes passed into the macro can be changed.
# Currently, there is no syntax for returning a value from the macro,
# except by writing to a parameter or global symbol.
macro GET_SATURATED_AC0M(dest) {
@ifdef USE_40_BIT_SATURATION
	# If the 40-bit mode is disabled, no saturation is needed.
	if (!$(SR_40_MODE)) goto <no_saturation_needed>;
	# If the accumulator is the same as its s32 version, no saturation is needed.
	if (ac0 == sext(ac0:4)) goto <no_saturation_needed>;
	# Saturation is needed; check if it needs to be be positive or negative.
	if (ac0 s< 0) goto <negative_saturation>;
	# Positive
	dest = 0x7fff;
	goto <done>;
	<negative_saturation>
	dest = 0x8000;
	goto <done>;
	<no_saturation_needed>
@endif
	dest = ac0.m;
	goto <done>;
	<done>
}
macro GET_SATURATED_AC1M(dest) {
@ifdef USE_40_BIT_SATURATION
	# If the 40-bit mode is disabled, no saturation is needed.
	if (!$(SR_40_MODE)) goto <no_saturation_needed>;
	# If the accumulator is the same as its s32 version, no saturation is needed.
	if (ac1 == sext(ac1:4)) goto <no_saturation_needed>;
	# Saturation is needed; check if it needs to be be positive or negative.
	if (ac1 s< 0) goto <negative_saturation>;
	# Positive
	dest = 0x7fff;
	goto <done>;
	<negative_saturation>
	dest = 0x8000;
	goto <done>;
	<no_saturation_needed>
@endif
	dest = ac1.m;
	goto <done>;
	<done>
}

sign_extend_reg0_5_after: is reg0_5 {}
sign_extend_reg0_5_after: is reg0_5=0x10 { ac0.h = sext(ac0.hreal); }
sign_extend_reg0_5_after: is reg0_5=0x11 { ac1.h = sext(ac1.hreal); }
sign_extend_reg0_5_after: is reg0_5=0x1E { SIGN_EXTEND_AC0M(); }
sign_extend_reg0_5_after: is reg0_5=0x1F { SIGN_EXTEND_AC1M(); }

saturated_reg0_5: is reg0_5 { export reg0_5; }
saturated_reg0_5: is reg0_5=0x10 { local tmp:2 = sext(ac0.hreal); export tmp; }
saturated_reg0_5: is reg0_5=0x11 { local tmp:2 = sext(ac1.hreal); export tmp; }
saturated_reg0_5: is reg0_5=0x1E { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_reg0_5: is reg0_5=0x1F { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

sign_extend_reg5_10_after: is reg5_10 {}
sign_extend_reg5_10_after: is reg5_10=0x10 { ac0.h = sext(ac0.hreal); }
sign_extend_reg5_10_after: is reg5_10=0x11 { ac1.h = sext(ac1.hreal); }
sign_extend_reg5_10_after: is reg5_10=0x1E { SIGN_EXTEND_AC0M(); }
sign_extend_reg5_10_after: is reg5_10=0x1F { SIGN_EXTEND_AC1M(); }

attach variables [ ar0_2 ar5_7 ] [ ar0 ar1 ar2 ar3 ];
attach variables [ ix0_2 ix2_4 ix5_7 ] [ ix0 ix1 ix2 ix3 ];

attach variables [ reg5_8 ] [ ar0 ar1 ar2 ar3 ix0 ix1 ix2 ix3 ];

attach variables [ acm8 ] [ ac0.m ac1.m ]; # Middle of 40-bit accumulators
attach variables [ acf8 ] [ ac0 ac1 ]; # Full 40-bit accumulators
attach variables [ acs8 ] [ acs0 acs1 ]; # 24 bits of 40-bit accumulators
attach variables [ ac8_11 ] [ ax0.l ax1.l ax0.h ax1.h ac0.l ac1.l ac0.m ac1.m ]; # 3-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ ac8_10 ] [ ac0.l ac1.l ac0.m ac1.m ]; # 2-bit field referring to a register starting at 0x1C (ac0.l)
attach variables [ ach8display ] [ ac0.h ac1.h ]; # Top of 40-bit accumulators
attach variables [ ach8 ] [ ac0.hreal ac1.hreal ]; # Top of 40-bit accumulators, as 8-bit registers

sign_extend_acm8_after: is acm8=0 { SIGN_EXTEND_AC0M(); }
sign_extend_acm8_after: is acm8=1 { SIGN_EXTEND_AC1M(); }

sign_extend_ac8_11_after: is ac8_11 {}
sign_extend_ac8_11_after: is ac8_11=6 { SIGN_EXTEND_AC0M(); }
sign_extend_ac8_11_after: is ac8_11=7 { SIGN_EXTEND_AC1M(); }

saturated_ac8_10: is ac8_10 { export ac8_10; }
saturated_ac8_10: is ac8_10=2 { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_ac8_10: is ac8_10=3 { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

@ifdef USE_REAL_SR_REGISTER
# Offset by 6
attach names srbit [ SR_LOGIC_ZERO SR_OVERFLOW_STICKY SR_100 SR_INT_ENABLE SR_400 SR_EXT_INT_ENABLE SR_1000 SR_MUL_MODIFY ];
@else
attach variables srbit [ SR_LOGIC_ZERO_ SR_OVERFLOW_STICKY_ SR_100_ SR_INT_ENABLE_ SR_400_ SR_EXT_INT_ENABLE_ SR_1000_ SR_MUL_MODIFY_ ];
@endif

# GCDSP also supports extension instructions, where a 1-byte arithmetic
# instruction is followed by a 1-byte extension instruction.
# This is written as e.g. 46 51 ADDR'L ac0, ax1.h : ax0.h, @ar1 where
# 46 corresponds to ADDR ac0, ax1.h and 51 corresponds to 'L ax0.h, @ar1.
# SLEIGH lets us have two separate tokens which can form two tables that
# are merged later, which could be used for implementing this.
#
# Unfortunately, the two-separate-bytes model is not accurate, as arithmetic
# instructions with an opcode starting with 3 actually use 9 bytes, leaving
# the remaining 7 for extension instructions.  Thus, a single merged token
# is used instead.
define token axopbyte (16)
	# Opbyte for arithmetic instructions
	aop0_8 = (8,  15) # (0, 7)
	aop4_8 = (12, 15) # (4, 7)
	aop5_8 = (13, 15) # (5, 7)
	aop2_4 = (10, 11) # (2, 3)
	aop1   = (9,  9)  # (1, 1)
	aop3   = (11, 11) # (3, 3)
	aop0_3 = (8,  10) # (0, 2)
	aop1_4 = (9,  11) # (1, 3)
	aop1_3 = (9,  10) # (1, 2)

	aacl0 = (8, 8) # (0, 0) # Low part of 40-bit accumulator

	aacm0 = (8, 8) # (0, 0) # Middle of 40-bit accumulator
	aacm1 = (9, 9) # (1, 1) # Middle of 40-bit accumulator
	aacm0_other = (8, 8) # (0, 0) # Middle of 40-bit accumulator, backwards
	aacm4 = (12, 12) # (4, 4) # Middle of 40-bit accumulator

	aacf0 = (8, 8) # (0, 0) # Full 40 bits of an accumulator
	aacf0_other = (8, 8) # (0, 0) # Full 40 bits of an accumulator, backwards
	aacf3 = (11, 11) # (3, 3) # Full 40 bits of an accumulator

	aacs0 = (8, 8) # (0, 0) # 24 bits of a 40-bit accumulator

	aaxh0 = (8,  8)  # (0, 0) # High bits of 32-bit accumulator
	aaxh1 = (9,  9)  # (1, 1) # High bits of 32-bit accumulator
	aaxh3 = (11, 11) # (3, 3) # High bits of 32-bit accumulator
	aaxh4 = (12, 12) # (4, 4) # High bits of 32-bit accumulator
	aaxl0 = (8,  8)  # Low bits of 32-bit accumulator
	aaxl1 = (9,  9)  # Low bits of 32-bit accumulator
	aaxl3 = (11, 11) # Low bits of 32-bit accumulator
	aaxf1 = (9,  9)  # Full 32 bits of an accumulator
	aax1_2 = (9, 10) # (1, 2) # 32-bit accumulator

	aax0lh1 = (9,  9)  # (1, 1) # Either ax0.l or ax0.h
	aax0lh4 = (12, 12) # (4, 4) # Either ax0.l or ax0.h
	aax1lh0 = (8,  8)  # (0, 0) # Either ax1.l or ax1.h
	aax1lh3 = (11, 11) # (3, 3) # Either ax1.l or ax1.h

	# Bit that belongs in xop but is used by arithmetic ops where aop4_8=0b0011
	axbit = (7, 7)

	# Opbyte for extension instructions
	xop0_2 = (0, 1)
	xop0_7 = (0, 6)
	xop4_7 = (4, 6)
	xop4_6 = (4, 5)
	xop1   = (1, 1)
	xop2   = (2, 2)
	xop5   = (5, 5)
	xop6   = (6, 6)
	xop2_4 = (2, 3)

	xar0_2 = (0, 1) # Addressing register
	xix0_2 = (0, 1) # Index register
	xac3_6 = (3, 5) # Either accumulator
	xax2_4 = (2, 3) # 32-bit accumulator
	xax4_6 = (4, 5) # 32-bit accumulator
	xac0_2 = (0, 1) # 40-bit accumulator
	xac3_5 = (3, 4) # 40-bit accumulator
	xacm0  = (0, 0) # Either ac0.m or ac1.m

	xax0lh5 = (5, 5) # Either ax0.l or ax0.h
	xax1lh4 = (4, 4) # Either ax1.l or ax1.h

	xax4  = (4, 4) # Either ax0 or ax1
	xaxl4 = (4, 4) # Either ax0.l or ax1.l
	xaxh4 = (4, 4) # Either ax0.h or ax1.h

	xar5 = (5, 5) # Either ar0 or ar1; ar2 and ar3 are not selectable
	xix5 = (5, 5) # Either ix0 or ix1
;

# Variables for arithmetic opcodes
attach variables [ aacl0 ] [ ac0.l ac1.l ];
attach variables [ aacm0 aacm1 aacm4 ] [ ac0.m ac1.m ];
attach variables [ aacm0_other ] [ ac1.m ac0.m ];
attach variables [ aacf0 aacf3 ] [ ac0 ac1 ];
attach variables [ aacf0_other ] [ ac1 ac0 ];
attach variables [ aacs0 ] [ acs0 acs1 ];
attach variables [ aaxh0 aaxh1 aaxh3 aaxh4 ] [ ax0.h ax1.h ];
attach variables [ aaxl0 aaxl1 aaxl3 ] [ ax0.l ax1.l ];
attach variables [ aax1_2 ] [ ax0.l ax1.l ax0.h ax1.h ]; # 2-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ aaxf1 ] [ ax0 ax1 ];

attach variables [ aax0lh1 aax0lh4 ] [ ax0.l ax0.h ];
attach variables [ aax1lh0 aax1lh3 ] [ ax1.l ax1.h ];

# Variables for extension opcodes
attach variables [ xar0_2 ] [ ar0 ar1 ar2 ar3 ];
attach variables [ xix0_2 ] [ ix0 ix1 ix2 ix3 ];
attach variables [ xac3_6 ] [ ax0.l ax1.l ax0.h ax1.h ac0.l ac1.l ac0.m ac1.m ]; # 3-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ xax2_4 xax4_6 ] [ ax0.l ax1.l ax0.h ax1.h ]; # 2-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ xac0_2 xac3_5 ] [ ac0.l ac1.l ac0.m ac1.m ]; # 2-bit field referring to a register starting at 0x1C (ac0.l)
attach variables [ xacm0 ] [ ac0.m ac1.m ];

sign_extend_xac3_6_after: is xac3_6 {}
sign_extend_xac3_6_after: is xac3_6=6 { SIGN_EXTEND_AC0M(); }
sign_extend_xac3_6_after: is xac3_6=7 { SIGN_EXTEND_AC1M(); }

saturated_xac0_2: is xac0_2 { export xac0_2; }
saturated_xac0_2: is xac0_2=2 { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_xac0_2: is xac0_2=3 { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

saturated_xac3_5: is xac3_5 { export xac3_5; }
saturated_xac3_5: is xac3_5=2 { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_xac3_5: is xac3_5=3 { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

saturated_xacm0: is xacm0=0 { local tmp:2; GET_SATURATED_AC0M(tmp); export tmp; }
saturated_xacm0: is xacm0=1 { local tmp:2; GET_SATURATED_AC1M(tmp); export tmp; }

attach variables [ xax0lh5 ] [ ax0.l ax0.h ];
attach variables [ xax1lh4 ] [ ax1.l ax1.h ];

attach variables [ xax4  ] [ ax0   ax1   ];
attach variables [ xaxl4 ] [ ax0.l ax1.l ];
attach variables [ xaxh4 ] [ ax0.h ax1.h ];

attach variables [ xar5 ] [ ar0 ar1 ];
attach variables [ xix5 ] [ ix0 ix1 ];

macro FLAGS16X(result, carry, overflow, over_s32) {
	$(SR_CARRY) = carry;  # Carry
	$(SR_OVERFLOW) = overflow;  # Overflow
	$(SR_ARITH_ZERO) = (result == 0);  # Zero
	$(SR_SIGN) = (result s< 0);  # Sign
	$(SR_OVER_32) = over_s32;  # Above s32
	$(SR_TOP2BITS) = ((result & 0xc000) == 0) || ((result & 0xc000) == 0xc000);  # Top 2 bits equal
	$(SR_OVERFLOW_STICKY) = $(SR_OVERFLOW_STICKY) | $(SR_OVERFLOW);  # Sticky overflow
}

macro FLAGS16(result, result_40) {
	FLAGS16X(result, 0, 0, (result_40 != sext(result_40:4)));
}

macro FLAGS40X(result, carry, overflow) {
	# Flags for a 40-bit operation (like Dolphin's UpdateSR64)
	$(SR_CARRY) = carry;  # Carry
	$(SR_OVERFLOW) = overflow;  # Overflow
	$(SR_ARITH_ZERO) = (result == 0);  # Zero
	$(SR_SIGN) = (result s< 0);  # Sign
	$(SR_OVER_32) = (result != sext(result:4));  # Above s32
	$(SR_TOP2BITS) = ((result & 0xc0000000) == 0) || ((result & 0xc0000000) == 0xc0000000);  # Top 2 bits equal
	$(SR_OVERFLOW_STICKY) = $(SR_OVERFLOW_STICKY) | $(SR_OVERFLOW);  # Sticky overflow
}

macro FLAGS40(result) {
	FLAGS40X(result, 0, 0);
}

macro FLAGS_ADD40(a, b) {
	# Flags for a 40-bit add (like Dolphin's UpdateSR64Add)
	# Carry uses an unsigned comparison to match Dolphin's isCarrySubtract.
	# Comparing Dolphin's isOverflow in DSPIntCCUtil.h and Ghidra's OpBehaviorIntScarry.java,
	# scarry seems to match our desired behavior here.  Note that this is the same for add and subtract
	FLAGS40X(a + b, (a > (a + b)), scarry(a, b));
}

macro FLAGS_SUB40(a, b) {
	# Flags for a 40-bit subtract (like Dolphin's UpdateSR64Sub)
	# Carry uses an unsigned comparison to match Dolphin's isCarrySubtract.
	# Comparing Dolphin's isOverflow in DSPIntCCUtil.h and Ghidra's OpBehaviorIntScarry.java,
	# scarry seems to match our desired behavior here.  Note that this is the same for add and subtract
	FLAGS40X(a - b, (a >= (a - b)), scarry(a, -b));
}

op:"NOP" is op0_4=0 & op4_8=0 & op8_16=0 {
}

op:"DAR" ar0_2 is ar0_2 & op2_4=0b01 & op4_8=0 & op8_16=0 {
	ar0_2 = ar0_2 - 1;
}

op:"IAR" ar0_2 is ar0_2 & op2_4=0b10 & op4_8=0 & op8_16=0 {
	ar0_2 = ar0_2 - 1;
}

op:"SUBARN" ar0_2, ix0_2 is ar0_2 & op2_4=0b11 & op4_8=0b0000 & op8_16=0 & ix0_2 {
	ar0_2 = ar0_2 - ix0_2;
}

op:"ADDARN" ar0_2, ix2_4 is ar0_2 & ix2_4 & op4_8=0b0001 & op8_16=0 {
	ar0_2 = ar0_2 + ix2_4;
}

op:"HALT" is op0_4=0b0001 & op4_8=0b0010 & op8_16=0 {
	goto inst_start; # Infinite loop
}

op:"LOOP" reg0_5          is reg0_5 & op5_8=0b010 & op8_16=0 & saturated_reg0_5 [
	hasloopcheck = 1;
	hasloopjumpback = 1;
	loopskipaddr = inst_start + 2;
	loopjumpbackaddr = inst_start + 1;
	globalset(inst_next, hasloopcheck);
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopskipaddr);
	globalset(inst_next, loopjumpbackaddr);
] {
	st3 = saturated_reg0_5;
}
@ifndef BLOOP_ONE_AFTER
op:"BLOOP" reg0_5, Addr16 is reg0_5 & op5_8=0b011 & op8_16=0 & saturated_reg0_5; Addr16 & imm16
@else
op:"BLOOP" reg0_5, Addr16After is reg0_5 & op5_8=0b011 & op8_16=0 & saturated_reg0_5; Addr16 & Addr16After & imm16
@endif
[
	hasloopcheck = 1;
	hasloopjumpback = 1;
	loopskipaddr = imm16 + 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(inst_next, hasloopcheck);
	globalset(Addr16, hasloopjumpback);
	globalset(inst_next, loopskipaddr);
	globalset(Addr16, loopjumpbackaddr);
] {
	st3 = saturated_reg0_5;
}

op:"LRI" reg0_5, Imm16 is reg0_5 & op5_8=0b100 & op8_16=0 & sign_extend_reg0_5_after; Imm16 {
	reg0_5 = Imm16;
	build sign_extend_reg0_5_after;
}

# No instruction with op5_8=0b101 & op8_16=0

op:"LR" reg0_5, Mem16 is reg0_5 & op5_8=0b110 & op8_16=0 & sign_extend_reg0_5_after; Mem16 {
	reg0_5 = Mem16;
	build sign_extend_reg0_5_after;
}

op:"SR" Mem16, reg0_5 is reg0_5 & op5_8=0b111 & op8_16=0 & saturated_reg0_5; Mem16 {
	Mem16 = saturated_reg0_5;
}

cc: "GE"  is cc0_4=0b0000 { c:1 = ($(SR_OVERFLOW) == $(SR_SIGN)); export c; }
cc: "L"   is cc0_4=0b0001 { c:1 = ($(SR_OVERFLOW) != $(SR_SIGN)); export c; }
cc: "G"   is cc0_4=0b0010 { c:1 = (($(SR_OVERFLOW) == $(SR_SIGN)) && !$(SR_ARITH_ZERO)); export c; }
cc: "LE"  is cc0_4=0b0011 { c:1 = (($(SR_OVERFLOW) != $(SR_SIGN)) || $(SR_ARITH_ZERO)); export c; }
cc: "NZ"  is cc0_4=0b0100 { c:1 = !$(SR_ARITH_ZERO); export c; }
cc: "Z"   is cc0_4=0b0101 { c:1 = $(SR_ARITH_ZERO); export c; }
cc: "NC"  is cc0_4=0b0110 { c:1 = !$(SR_CARRY); export c; }
cc: "C"   is cc0_4=0b0111 { c:1 = $(SR_CARRY); export c; }
cc: "x8"  is cc0_4=0b1000 { c:1 = !$(SR_OVER_32); export c; } # "Below s32"
cc: "x9"  is cc0_4=0b1001 { c:1 = $(SR_OVER_32); export c; } # "Above s32"
cc: "xA"  is cc0_4=0b1010 { c:1 = (($(SR_OVER_32) || $(SR_TOP2BITS)) && !$(SR_ARITH_ZERO)); export c; } # Per dolphin
cc: "xB"  is cc0_4=0b1011 { c:1 = ((!$(SR_OVER_32) && !$(SR_TOP2BITS)) || $(SR_ARITH_ZERO)); export c; } # Per dolphin
cc: "LNZ" is cc0_4=0b1100 { c:1 = !$(SR_LOGIC_ZERO); export c; }
cc: "LZ"  is cc0_4=0b1101 { c:1 = $(SR_LOGIC_ZERO); export c; }
cc: "O"   is cc0_4=0b1110 { c:1 = $(SR_OVERFLOW); export c; }
# The always variant (cc0_4=0b1111) isn't listed here, so it can be handled separately

op:"IF"^cc is cc & op4_8=0b0111 & op8_16=2 {
	if (!cc) goto inst_next;
	# Use delayslot to merge the next instruction; this makes goto inst_next skip past the merged instruction
	# (and also automatically marks the affected instruction, for free!)
	delayslot(1);
}

op:"J"^cc Addr16 is cc & op4_8=0b1001 & op8_16=2; Addr16 {
	if (!cc) goto inst_next;
	goto Addr16;
}

op:"CALL"^cc Addr16 is cc & op4_8=0b1011 & op8_16=2; Addr16 {
	st0 = inst_next;
	if (!cc) goto inst_next;
	call Addr16;
}

op:"RET"^cc is cc & op4_8=0b1101 & op8_16=2 {
	if (!cc) goto inst_next;

	return [st0];
}

op:"RTI"^cc is cc & op4_8=0b1111 & op8_16=2 {
	if (!cc) goto inst_next;

	tmp:2 = 0; # TODO: Return address
	return [tmp];
}

# Unconditional variants

# Unconditionally execute the next opcode, presumably... not very useful?  Mark as unimpl so that a warning occurs
op:"IF" is cc0_4=0b1111 & op4_8=0b0111 & op8_16=2 unimpl

op:"JMP" Addr16 is cc0_4=0b1111 & op4_8=0b1001 & op8_16=2; Addr16 {
	goto Addr16;
}

op:"CALL" Addr16 is cc0_4=0b1111 & op4_8=0b1011 & op8_16=2; Addr16 {
	st0 = inst_next;
	call Addr16;
}

op:"RET" is cc0_4=0b1111 & op4_8=0b1101 & op8_16=2 {
	return [st0];
}

op:"RTI" is op0_4=0b1111 & op4_8=0b1111 & op8_16=2 {
	tmp:2 = 0; # TODO: Return address
	return [tmp];
}

op:"ADDI"  acs8, SImm16 is op0_4=0 & op4_8=0b0000 & acs8 & op9_16=1 & acf8; SImm16 { FLAGS_ADD40(acf8, sext(SImm16) << 16); acs8 = acs8 + sext(SImm16); }
op:"XORI"  acm8, Imm16 is op0_4=0 & op4_8=0b0010 & acm8 & op9_16=1 & acf8; Imm16 { acm8 = acm8 ^ Imm16; FLAGS16(acm8, acf8); }
op:"ANDI"  acm8, Imm16 is op0_4=0 & op4_8=0b0100 & acm8 & op9_16=1 & acf8; Imm16 { acm8 = acm8 & Imm16; FLAGS16(acm8, acf8); }
op:"ORI"   acm8, Imm16 is op0_4=0 & op4_8=0b0110 & acm8 & op9_16=1 & acf8; Imm16 { acm8 = acm8 | Imm16; FLAGS16(acm8, acf8); }
op:"CMPI"  acf8, SImm16 is op0_4=0 & op4_8=0b1000 & acf8 & op9_16=1; SImm16 { FLAGS_SUB40(acf8, sext(SImm16) << 16); }
op:"ANDF"  acm8, Imm16 is op0_4=0 & op4_8=0b1010 & acm8 & op9_16=1; Imm16 {
	$(SR_LOGIC_ZERO) = ((acm8 & Imm16) == 0);
}
op:"ANDCF" acm8, Imm16 is op0_4=0 & op4_8=0b1100 & acm8 & op9_16=1; Imm16 {
	$(SR_LOGIC_ZERO) = ((acm8 & Imm16) == Imm16);
}

op:"ILRR" acm8, "@"^ar0_2 is ar0_2 & op2_4=0 & op4_8=1 & acm8 & op9_16=1 & sign_extend_acm8_after {
	acm8 = *[inst]:2 ar0_2;
	build sign_extend_acm8_after;
}

op:"ILRRD" acm8, "@"^ar0_2 is ar0_2 & op2_4=1 & op4_8=1 & acm8 & op9_16=1 & sign_extend_acm8_after {
	acm8 = *[inst]:2 ar0_2;
	ar0_2 = ar0_2 - 1;
	build sign_extend_acm8_after;
}

op:"ILRRI" acm8, "@"^ar0_2 is ar0_2 & op2_4=2 & op4_8=1 & acm8 & op9_16=1 & sign_extend_acm8_after {
	acm8 = *[inst]:2 ar0_2;
	ar0_2 = ar0_2 + 1;
	build sign_extend_acm8_after;
}

# ar0_2 and ix0_2 are the same bits in the instruction.  The manual doesn't show ix0_2, but I've included it in the disassembly.
op:"ILRRN" acm8, "@"^ar0_2, ix0_2 is ar0_2 & op2_4=3 & op4_8=1 & acm8 & op9_16=1 & ix0_2 & sign_extend_acm8_after {
	acm8 = *[inst]:2 ar0_2;
	ar0_2 = ar0_2 + ix0_2;
	build sign_extend_acm8_after;
}

op:"ADDIS" acf8, SImm8 is SImm8 & acf8 & op9_16=0b0000010 & acs8 {
	FLAGS_ADD40(acf8, sext(SImm8) << 16);
	acs8 = acs8 + sext(SImm8);
}
op:"CMPIS" acf8, SImm8 is SImm8 & acf8 & op9_16=0b0000011 {
	FLAGS_SUB40(acf8, sext(SImm8) << 16);
}
op:"LRIS" ac8_11, SImm8 is SImm8 & ac8_11 & op11_16=0b00001 & sign_extend_ac8_11_after {
	ac8_11 = SImm8;
	build sign_extend_ac8_11_after;
}

op:"LOOPI" Imm8 is Imm8 & op8_16=0b00010000 [
	hasloopcheck = 1;
	hasloopjumpback = 1;
	loopskipaddr = inst_start + 2;
	loopjumpbackaddr = inst_start + 1;
	globalset(inst_next, hasloopcheck);
	globalset(inst_next, hasloopjumpback);
	globalset(inst_next, loopskipaddr);
	globalset(inst_next, loopjumpbackaddr);
] {
	st3 = Imm8;
}
@ifndef BLOOP_ONE_AFTER
op:"BLOOPI" Imm8, Addr16 is Imm8 & op8_16=0b00010001; Addr16 & imm16
@else
op:"BLOOPI" Imm8, Addr16After is Imm8 & op8_16=0b00010001; Addr16 & Addr16After & imm16
@endif
[
	hasloopcheck = 1;
	hasloopjumpback = 1;
	loopskipaddr = imm16 + 1;
	loopjumpbackaddr = inst_start + 2;
	globalset(inst_next, hasloopcheck);
	globalset(Addr16, hasloopjumpback);
	globalset(inst_next, loopskipaddr);
	globalset(Addr16, loopjumpbackaddr);
] {
	st3 = Imm8;
}

# op3_8 is marked as ????? in the table but shown as 0s for the instruction itself

op:"SBCLR" srbit is srbit & op3_8=0 & op8_16=0b00010010 {
@ifdef USE_REAL_SR_REGISTER
	sr = sr | 1 << (6 + srbit);
@else
	srbit = 1;
@endif
}
op:"SBSET" srbit is srbit & op3_8=0 & op8_16=0b00010011 {
@ifdef USE_REAL_SR_REGISTER
	sr = sr & ~(1 << (6 + srbit));
@else
	srbit = 0;
@endif
}

# The manual is written such that it implies LSL/LSR and ASL/ASR are the same instruction with a 7-bit signed immediate value,
# though it treats them as 2 pairs of instructions with a 6-bit value (allegedly somehow sign-extended for the right-shift)
op:"LSL" acf8, Imm6 is Imm6 & op6_8=0b00 & acf8 & op9_16=0b0001010 {
	acf8 = acf8 << Imm6;
	FLAGS40(acf8);
}
# To handle right shifts correctly, we subtract 64 and then negate.
# Dolphin decodes (well, used to; there's a regression with fmt currently) 1479 as "lsr $ACC0, #-7" which we change to "LSR ac0, #7".
# Without manual handling, you get "LSR ac0,#0x39" instead.
# Note that if the immediate value is 0, then a shift of 0 still occurs.  Imm6Right handles this.
op:"LSR" acf8, Imm6Right is Imm6Right & op6_8=0b01 & acf8 & op9_16=0b0001010  {
	acf8 = acf8 >> Imm6Right;
	FLAGS40(acf8);
}
op:"ASL" acf8, Imm6 is Imm6 & op6_8=0b10 & acf8 & op9_16=0b0001010 {
	# This doesn't do anything different, does it?
	acf8 = acf8 << Imm6;
	FLAGS40(acf8);
}
op:"ASR" acf8, Imm6Right is Imm6Right & op6_8=0b11 & acf8 & op9_16=0b0001010 {
	acf8 = acf8 s>> Imm6Right;
	FLAGS40(acf8);
}

@ifdef SIMPLIFY_SHIFTS
define pcodeop twowaylogicalshift;
define pcodeop twowayarithmeticshift;

macro TwoWayLogicalShift(value, shift) {
	value = twowaylogicalshift(value, shift);
	FLAGS40(value);
}

macro TwoWayArithmeticShift(value, shift) {
	value = twowayarithmeticshift(value, shift);
	FLAGS40(value);
}
@else
macro TwoWayLogicalShift(value, shift) {
	# Treated as a signed 7-bit field, like LSL/LSR
	if (shift[6,1] == 1) goto <rightshift>;

	# left shift
	value = value << shift[0,6];
	goto <done>;

	<rightshift>
	# A right-shift of 64 is actually a right-shift of 0
	if (shift[0,6] == 0) goto <done>;

	value = value >> (64 - shift[0,6]);

	<done>
	FLAGS40(value);
}

macro TwoWayArithmeticShift(value, shift) {
	# Treated as a signed 7-bit field, like ASL/ASR
	if (shift[6,1] == 1) goto <rightshift>;

	# left shift
	value = value << shift[0,6];
	goto <done>;

	<rightshift>
	# A right-shift of 64 is actually a right-shift of 0
	if (shift[0,6] == 0) goto <done>;

	value = value s>> (64 - shift[0,6]);

	<done>
	FLAGS40(value);
}
@endif

# TODO: Not documented.  Dolphin's DSPTables.cpp mentions "these two were discovered by ector".
# These two operate directly on ac0 and ac1.m.
op:"LSRN" is op0_4=0b1010 & op4_8=0b1100 & op8_16=2 {
	TwoWayLogicalShift(ac0, ac1.m);
}
op:"ASRN" is op0_4=0b1011 & op4_8=0b1100 & op8_16=2 {
	TwoWayArithmeticShift(ac0, ac1.m);
}

op:"SI" Mem8FF, Imm16 is Mem8FF & op8_16=0b00010110; Imm16 {
	Mem8FF = Imm16;
}

op:"CALLR" reg5_8 is op0_5=0b11111 & reg5_8 & op8_16=0b00010111 {
	# TODO: Update stack
	call [reg5_8];
}
op:"JMPR" reg5_8 is op0_5=0b01111 & reg5_8 & op8_16=0b00010111 {
	goto [reg5_8];
}

op:"CALLR"^cc reg5_8 is cc & op5=1 & reg5_8 & op8_16=0b00010111 {
	if (!cc) goto inst_next;
	# TODO: Update stack
	call [reg5_8];
}
op:"JR"^cc reg5_8 is cc & op5=0 & reg5_8 & op8_16=0b00010111 {
	if (!cc) goto inst_next;
	goto [reg5_8];
}

op:"LRR"  reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b00 & op9_16=0b0001100 & sign_extend_reg0_5_after {
	reg0_5 = *:2 ar5_7;
	build sign_extend_reg0_5_after;
}
op:"LRRD" reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b01 & op9_16=0b0001100 & sign_extend_reg0_5_after {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 - 1;
	build sign_extend_reg0_5_after;
}
op:"LRRI" reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b10 & op9_16=0b0001100 & sign_extend_reg0_5_after {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 + 1;
	build sign_extend_reg0_5_after;
}
op:"LRRN" reg0_5, "@"^ar5_7, ix5_7 is reg0_5 & ar5_7 & op7_9=0b11 & op9_16=0b0001100 & ix5_7 & sign_extend_reg0_5_after {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 + ix5_7;  # ar5_7 and ix5_7 are the same bits in the instruction.  I've included it in the disassembly, but it's not like that in the manual.
	build sign_extend_reg0_5_after;
}

op:"SRR"  "@"^ar5_7, reg0_5 is reg0_5 & ar5_7 & op7_9=0b00 & op9_16=0b0001101 & saturated_reg0_5 {
	*:2 ar5_7 = saturated_reg0_5;
}
op:"SRRD" "@"^ar5_7, reg0_5 is reg0_5 & ar5_7 & op7_9=0b01 & op9_16=0b0001101 & saturated_reg0_5 {
	*:2 ar5_7 = saturated_reg0_5;
	ar5_7 = ar5_7 - 1;
}
op:"SRRI" "@"^ar5_7, reg0_5 is reg0_5 & ar5_7 & op7_9=0b10 & op9_16=0b0001101 & saturated_reg0_5 {
	*:2 ar5_7 = saturated_reg0_5;
	ar5_7 = ar5_7 + 1;
}
op:"SRRN" "@"^ar5_7, reg0_5, ix5_7 is reg0_5 & ar5_7 & op7_9=0b11 & op9_16=0b0001101 & ix5_7 & saturated_reg0_5 {
	*:2 ar5_7 = saturated_reg0_5;
	ar5_7 = ar5_7 + ix5_7;  # ar5_7 and ix5_7 are the same bits in the instruction.  I've included it in the disassembly, but it's not like that in the manual.
}

op:"MRR" reg5_10, reg0_5 is reg0_5 & reg5_10 & op10_16=0b000111 & sign_extend_reg5_10_after & saturated_reg0_5 {
	reg5_10 = saturated_reg0_5;
	build sign_extend_reg5_10_after;
}

op:"LRS" ac8_11, Mem8CR is Mem8CR & ac8_11 & op11_16=0b00100 & sign_extend_ac8_11_after {
	ac8_11 = Mem8CR;
	build sign_extend_ac8_11_after;
}
# 0b0010 100s mmmm mmmm
op:"SRSH" Mem8CR, ach8display is Mem8CR & ach8display & op9_16=0b0010100 & ach8 {
	Mem8CR = sext(ach8);
}
# 0b0010 101s mmmm mmmm is unused/unknown
# 0b0010 11ss mmmm mmmm
op:"SRS" Mem8CR, ac8_10 is Mem8CR & ac8_10 & op10_16=0b001011 & saturated_ac8_10 {
	Mem8CR = saturated_ac8_10;
}

# Define arithmetic opcodes and opcode parameters.
# We define them separately to match the format in the manual (OPC'EXOPC <opcode parameters> : <extended opcode parameters>).
# It would also be possible to have regular arithmetic instructions and extension instructions treated as two instructions by Ghirda,
# but that would have its own problems related to state.
# For instructions where multiple registers are handled from a single bit (e.g. aacm0 and aacf0 below), the duplicate are included
# in both bit patterns, even though it is only meaningful in the a_opp table, to make it easy to verify that both patterns are the same.

# Dolphin's DSPTables.cpp indicates that there's some extra dumbness that happens when aop4_8=0b0011:
# The arithmetic opcode is 9 bits and the extension is 7!  Or in other words, things are a bit of a mess...
a_opc:"XORR"       is aacm0 & aaxh1 & aop2_4=0 & aop4_8=0b0011 & axbit=0 & aacf0 {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aop2_4=0 & aop4_8=0b0011 & axbit=0 & aacf0 {
	aacm0 = aacm0 ^ aaxh1;
	FLAGS16(aacm0, aacf0);
}

a_opc:"ANDR"       is aacm0 & aaxh1 & aop2_4=1 & aop4_8=0b0011 & axbit=0 & aacf0 {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aop2_4=1 & aop4_8=0b0011 & axbit=0 & aacf0 {
	aacm0 = aacm0 & aaxh1;
	FLAGS16(aacm0, aacf0);
}

a_opc:"ORR"        is aacm0 & aaxh1 & aop2_4=2 & aop4_8=0b0011 & axbit=0 & aacf0 {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aop2_4=2 & aop4_8=0b0011 & axbit=0 & aacf0 {
	aacm0 = aacm0 | aaxh1;
	FLAGS16(aacm0, aacf0);
}

a_opc:"ANDC"             is aacm0 & aop1=0 & aop2_4=3 & aop4_8=0b0011 & axbit=0 & aacm0_other & aacf0 {}
a_opp:aacm0, aacm0_other is aacm0 & aop1=0 & aop2_4=3 & aop4_8=0b0011 & axbit=0 & aacm0_other & aacf0 {
	aacm0 = aacm0 & aacm0_other;
	FLAGS16(aacm0, aacf0);
}

a_opc:"ORC"              is aacm0 & aop1=1 & aop2_4=3 & aop4_8=0b0011 & axbit=0 & aacm0_other & aacf0 {}
a_opp:aacm0, aacm0_other is aacm0 & aop1=1 & aop2_4=3 & aop4_8=0b0011 & axbit=0 & aacm0_other & aacf0 {
	aacm0 = aacm0 | aacm0_other;
	FLAGS16(aacm0, aacf0);
}

a_opc:"XORC"             is aacm0 & aop1=0 & aop2_4=0 & aop4_8=0b0011 & axbit=1 & aacm0_other & aacf0 {}
a_opp:aacm0, aacm0_other is aacm0 & aop1=0 & aop2_4=0 & aop4_8=0b0011 & axbit=1 & aacm0_other & aacf0 {
	aacm0 = aacm0 ^ aacm0_other;
	FLAGS16(aacm0, aacf0);
}

a_opc:"NOT" is aacm0 & aop1=1 & aop2_4=0 & aop4_8=0b0011 & axbit=1 & aacf0 {}
a_opp:aacm0 is aacm0 & aop1=1 & aop2_4=0 & aop4_8=0b0011 & axbit=1 & aacf0 {
	aacm0 = ~aacm0;
	FLAGS16(aacm0, aacf0);
}

a_opc:"LSRNRX"     is aacf0 & aaxh1 & aop2_4=1 & aop4_8=0b0011 & axbit=1 {}
a_opp:aacf0, aaxh1 is aacf0 & aaxh1 & aop2_4=1 & aop4_8=0b0011 & axbit=1 {
	TwoWayLogicalShift(aacf0, aaxh1[0,6]);
}

a_opc:"ASRNRX"     is aacf0 & aaxh1 & aop2_4=2 & aop4_8=0b0011 & axbit=1 {}
a_opp:aacf0, aaxh1 is aacf0 & aaxh1 & aop2_4=2 & aop4_8=0b0011 & axbit=1 {
	TwoWayArithmeticShift(aacf0, aaxh1[0,6]);
}

a_opc:"LSRNR"            is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0011 & axbit=1 & aacm0_other {}
a_opp:aacf0, aacm0_other is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0011 & axbit=1 & aacm0_other {
	TwoWayLogicalShift(aacf0, aacm0_other);
}

a_opc:"ASRNR"            is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0011 & axbit=1 & aacm0_other {}
a_opp:aacf0, aacm0_other is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0011 & axbit=1 & aacm0_other {
	TwoWayArithmeticShift(aacf0, aacm0_other);
}

# Remaining arithmetic instructions, where aop4_8 != 0b0011:
a_opc:"ADDR"        is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0100 {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0100 {
	FLAGS_ADD40(aacf0, sext(aax1_2));
	aacf0 = aacf0 + sext(aax1_2);
}

a_opc:"ADDAX"      is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0100 {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0100 {
	FLAGS_ADD40(aacf0, sext(aaxf1));
	aacf0 = aacf0 + sext(aaxf1);
}

a_opc:"ADD"              is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0100 & aacf0_other {}
a_opp:aacf0, aacf0_other is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0100 & aacf0_other {
	FLAGS_ADD40(aacf0, aacf0_other);
	aacf0 = aacf0 + aacf0_other;
}

a_opc:"ADDP" is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0100 {}
a_opp:aacf0  is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0100 {
	FLAGS_ADD40(aacf0, prod);
	aacf0 = aacf0 + prod;
}

a_opc:"SUBR"        is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0101 {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0101 {
	FLAGS_SUB40(aacf0, sext(aax1_2));
	aacf0 = aacf0 - sext(aax1_2);
}

a_opc:"SUBAX"      is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0101 {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0101 {
	FLAGS_SUB40(aacf0, sext(aaxf1));
	aacf0 = aacf0 - sext(aaxf1);
}

a_opc:"SUB"              is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0101 & aacf0_other {}
a_opp:aacf0, aacf0_other is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0101 & aacf0_other {
	FLAGS_SUB40(aacf0, aacf0_other);
	aacf0 = aacf0 - aacf0_other;
}

a_opc:"SUBP" is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0101 {}
a_opp:aacf0  is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0101 {
	FLAGS_SUB40(aacf0, prod);
	aacf0 = aacf0 - prod;
}

a_opc:"MOVR"        is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0110 {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0110 {
	# high bits sign-extended, middle bits based on value, low bits zeroed
	# TODO: Use aacs0?
	aacf0 = sext(aax1_2) << 16;
	FLAGS40(aacf0);
}

a_opc:"MOVAX"      is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0110 {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0110 {
	aacf0 = sext(aaxf1);
	FLAGS40(aacf0);
}

a_opc:"MOV"              is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0110 & aacf0_other {}
a_opp:aacf0, aacf0_other is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0110 & aacf0_other {
	aacf0 = aacf0_other;
	FLAGS40(aacf0);
}

a_opc:"MOVP" is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0110 {}
a_opp:aacf0  is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0110 {
	aacf0 = prod;
	FLAGS40(aacf0);
}

a_opc:"ADDAXL"     is aacf0 & aaxl1 & aop2_4=0 & aop4_8=0b0111 {}
a_opp:aacf0, aaxl1 is aacf0 & aaxl1 & aop2_4=0 & aop4_8=0b0111 {
	FLAGS_ADD40(aacf0, zext(aaxl1));
	aacf0 = aacf0 + zext(aaxl1);  # Note: unsigned extension
}

a_opc:"INCM" is aacs0 & aop1=0 & aop2_4=1 & aop4_8=0b0111 & aacf0 {}
a_opp:aacs0  is aacs0 & aop1=0 & aop2_4=1 & aop4_8=0b0111 & aacf0 {
	FLAGS_ADD40(aacf0, 0x10000);
	aacs0 = aacs0 + 1;
}

a_opc:"INC" is aacf0 & aop1=1 & aop2_4=1 & aop4_8=0b0111 {}
a_opp:aacf0 is aacf0 & aop1=1 & aop2_4=1 & aop4_8=0b0111 {
	FLAGS_ADD40(aacf0, 1);
	aacf0 = aacf0 + 1;
}

a_opc:"DECM" is aacs0 & aop1=0 & aop2_4=2 & aop4_8=0b0111 & aacf0 {}
a_opp:aacs0  is aacs0 & aop1=0 & aop2_4=2 & aop4_8=0b0111 & aacf0 {
	FLAGS_SUB40(aacf0, 0x10000);
	aacs0 = aacs0 - 1;
}

a_opc:"DEC" is aacf0 & aop1=1 & aop2_4=2 & aop4_8=0b0111 {}
a_opp:aacf0 is aacf0 & aop1=1 & aop2_4=2 & aop4_8=0b0111 {
	FLAGS_SUB40(aacf0, 1);
	aacf0 = aacf0 - 1;
}

a_opc:"NEG" is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0111 {}
a_opp:aacf0 is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0111 {
	FLAGS_SUB40(0, aacf0);
	aacf0 = -aacf0;
}

a_opc:"MOVNP" is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0111 {}
a_opp:aacf0   is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0111 {
	aacf0 = -prod;
	FLAGS40(aacf0);
}

# A NOP that is used to specify only an extended opcode.  Bit 3 can be either 0 or 1.
a_opc:"NX" is aop0_3=0 & aop4_8=0b1000 {}
a_opp:""   is aop0_3=0 & aop4_8=0b1000 {}

a_opc:"CLR" is aop0_3=1 & aacf3 & aop4_8=0b1000 {}
a_opp:aacf3 is aop0_3=1 & aacf3 & aop4_8=0b1000 {
	aacf3 = 0;
	FLAGS40(aacf3);
}

a_opc:"CMP" is aop0_3=0b010 & aop3=0 & aop4_8=0b1000 {}
a_opp:""    is aop0_3=0b010 & aop3=0 & aop4_8=0b1000 {
	FLAGS_SUB40(ac0, ac1);
}

a_opc:"MULAXH" is aop0_3=0b011 & aop3=0 & aop4_8=0b1000 {}
a_opp:         is aop0_3=0b011 & aop3=0 & aop4_8=0b1000 {
	prod = zext(ax0.h) * zext(ax0.h);
}

a_opc:"CLRP" is aop0_3=0b100 & aop3=0 & aop4_8=0b1000 {}
a_opp:""     is aop0_3=0b100 & aop3=0 & aop4_8=0b1000 {
	prod.l  = 0x0000;
	prod.m1 = 0xfff0;
	prod.h  = 0x00ff;
	prod.m2 = 0x0010;
	prod = 0;
}

a_opc:"TSTPROD" is aop0_3=0b101 & aop3=0 & aop4_8=0b1000 {}
a_opp:          is aop0_3=0b101 & aop3=0 & aop4_8=0b1000 {
	FLAGS40(prod);
}

a_opc:"TSTAXH" is aaxh0 & aop1_4=0b011 & aop4_8=0b1000 {}
a_opp:aaxh0    is aaxh0 & aop1_4=0b011 & aop4_8=0b1000 {
	FLAGS16X(aaxh0, 0, 0, 0);
}

a_opc:"M2" is aop0_8=0b10001010 {}
a_opp:""   is aop0_8=0b10001010 { $(SR_MUL_MODIFY) = 0; }  # 0 indicates modified behavior here

a_opc:"M0" is aop0_8=0b10001011 {}
a_opp:""   is aop0_8=0b10001011 { $(SR_MUL_MODIFY) = 1; }

a_opc:"CLR15" is aop0_8=0b10001100 {}
a_opp:""      is aop0_8=0b10001100 { $(SR_MUL_UNSIGNED) = 0; }

a_opc:"SET15" is aop0_8=0b10001101 {}
a_opp:""      is aop0_8=0b10001101 { $(SR_MUL_UNSIGNED) = 1; }

a_opc:"SET16" is aop0_8=0b10001110 {}
a_opp:""      is aop0_8=0b10001110 { $(SR_40_MODE) = 0; }

a_opc:"SET40" is aop0_8=0b10001111 {}
a_opp:""      is aop0_8=0b10001111 { $(SR_40_MODE) = 1; }

# TODO: "$sr.AM bit affects multiply result"
a_opc:"MUL"        is aop0_3=0b000 & aaxl3 & aop4_8=0b1001 & aaxh3 {}
a_opp:aaxl3, aaxh3 is aop0_3=0b000 & aaxl3 & aop4_8=0b1001 & aaxh3 { prod = sext(aaxl3) * sext(aaxh3); }

a_opc:"ASR16" is aop0_3=0b001 & aacf3 & aop4_8=0b1001 {}
a_opp:aacf3   is aop0_3=0b001 & aacf3 & aop4_8=0b1001 {
	aacf3 = aacf3 s>> 16;
	FLAGS40(aacf3);
}

a_opc:"MULMVZ"            is aacf0 & aop1_3=0b01 & aaxl3 & aop4_8=0b1001 & aaxh3 {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aop1_3=0b01 & aaxl3 & aop4_8=0b1001 & aaxh3 {
	aacf0 = prod & 0xffffffff0000;
	prod = sext(aaxl3) * sext(aaxh3);
	FLAGS40(aacf0);
}

a_opc:"MULAC"             is aacf0 & aop1_3=0b10 & aaxl3 & aop4_8=0b1001 & aaxh3 {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aop1_3=0b10 & aaxl3 & aop4_8=0b1001 & aaxh3 {
	aacf0 = aacf0 + prod;
	prod = sext(aaxl3) * sext(aaxh3);
	FLAGS40(aacf0);
}

a_opc:"MULMV"             is aacf0 & aop1_3=0b11 & aaxl3 & aop4_8=0b1001 & aaxh3 {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aop1_3=0b11 & aaxl3 & aop4_8=0b1001 & aaxh3 {
	aacf0 = prod;
	prod = sext(aaxl3) * sext(aaxh3);
	FLAGS40(aacf0);
}

a_opc:"MULX"           is aop0_3=0b000 & aax1lh3 & aax0lh4 & aop5_8=0b101 & aaxh3 {}
a_opp:aax0lh4, aax1lh3 is aop0_3=0b000 & aax1lh3 & aax0lh4 & aop5_8=0b101 & aaxh3 {
	prod = sext(aax0lh4) * sext(aax1lh3);
}

a_opc:"ABS" is aop0_3=0b001 & aacf3 & aop4_8=0b1010 {}
a_opp:aacf3 is aop0_3=0b001 & aacf3 & aop4_8=0b1010 {
	aacf3 = abs(aacf3);
	FLAGS40(aacf3);
}

a_opc:"TST" is aop0_3=0b001 & aacf3 & aop4_8=0b1011 {}
a_opp:aacf3 is aop0_3=0b001 & aacf3 & aop4_8=0b1011 {
	FLAGS40(aacf3);
}

a_opc:"MULXMVZ"               is aacf0 & aop1_3=0b01 & aax1lh3 & aax0lh4 & aop5_8=0b101 {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aop1_3=0b01 & aax1lh3 & aax0lh4 & aop5_8=0b101 {
	aacf0 = prod & 0xffffffff0000;
	prod = sext(aax0lh4) * sext(aax1lh3);
	FLAGS40(aacf0);
}

a_opc:"MULXAC"                is aacf0 & aop1_3=0b10 & aax1lh3 & aax0lh4 & aop5_8=0b101 {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aop1_3=0b10 & aax1lh3 & aax0lh4 & aop5_8=0b101 {
	aacf0 = aacf0 + prod;
	prod = sext(aax0lh4) * sext(aax1lh3);
	FLAGS40(aacf0);
}

a_opc:"MULXMV"                is aacf0 & aop1_3=0b11 & aax1lh3 & aax0lh4 & aop5_8=0b101 {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aop1_3=0b11 & aax1lh3 & aax0lh4 & aop5_8=0b101 {
	aacf0 = prod;
	prod = sext(aax0lh4) * sext(aax1lh3);
	FLAGS40(aacf0);
}

a_opc:"MULC"       is aop0_3=0b000 & aaxh3 & aacm4 & aop5_8=0b110 {}
a_opp:aacm4, aaxh3 is aop0_3=0b000 & aaxh3 & aacm4 & aop5_8=0b110 {
	prod = sext(aacm4) * sext(aaxh3);
}

a_opc:"CMPAXH"     is aop0_3=0b001 & aacf3 & aaxh4 & aop5_8=0b110 {}
a_opp:aacf3, aaxh4 is aop0_3=0b001 & aacf3 & aaxh4 & aop5_8=0b110 {
	FLAGS_SUB40(aacf3, (sext(aaxh4) << 16));
}

a_opc:"MULCMVZ"           is aacf0 & aop1_3=0b01 & aaxh3 & aacm4 & aop5_8=0b110 {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aop1_3=0b01 & aaxh3 & aacm4 & aop5_8=0b110 {
	aacf0 = prod & 0xffffffff0000;
	prod = sext(aacm4) * sext(aaxh3);
	FLAGS40(aacf0);
}

a_opc:"MULCAC"            is aacf0 & aop1_3=0b10 & aaxh3 & aacm4 & aop5_8=0b110 {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aop1_3=0b10 & aaxh3 & aacm4 & aop5_8=0b110 {
	aacf0 = aacf0 + prod;
	prod = sext(aacm4) * sext(aaxh3);
	FLAGS40(aacf0);
}

a_opc:"MULCMV"            is aacf0 & aop1_3=0b11 & aaxh3 & aacm4 & aop5_8=0b110  {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aop1_3=0b11 & aaxh3 & aacm4 & aop5_8=0b110 {
	aacf0 = prod;
	prod = sext(aacm4) * sext(aaxh3);
	FLAGS40(aacf0);
}

a_opc:"MADDX"          is aax1lh0 & aax0lh1 & aop2_4=0b00 & aop4_8=0b1110 {}
a_opp:aax0lh1, aax1lh0 is aax1lh0 & aax0lh1 & aop2_4=0b00 & aop4_8=0b1110 {
	prod = prod + (sext(aax0lh1) * sext(aax1lh0));
}

a_opc:"MSUBX"          is aax1lh0 & aax0lh1 & aop2_4=0b01 & aop4_8=0b1110 {}
a_opp:aax0lh1, aax1lh0 is aax1lh0 & aax0lh1 & aop2_4=0b01 & aop4_8=0b1110 {
	prod = prod - (sext(aax0lh1) * sext(aax1lh0));
}

a_opc:"MADDC"      is aaxh0 & aacm1 & aop2_4=0b10 & aop4_8=0b1110 {}
a_opp:aacm1, aaxh0 is aaxh0 & aacm1 & aop2_4=0b10 & aop4_8=0b1110 {
	prod = prod + (sext(aacm1) * sext(aaxh0));
}

a_opc:"MSUBC"      is aaxh0 & aacm1 & aop2_4=0b11 & aop4_8=0b1110 {}
a_opp:aacm1, aaxh0 is aaxh0 & aacm1 & aop2_4=0b11 & aop4_8=0b1110 {
	prod = prod - (sext(aacm1) * sext(aaxh0));
}
a_opc:"LSL16" is aacf0 & aop1_4=0b000 & aop4_8=0b1111 {}
a_opp:aacf0   is aacf0 & aop1_4=0b000 & aop4_8=0b1111 {
	aacf0 = aacf0 << 16;
	FLAGS40(aacf0);
}

a_opc:"MADD"       is aaxl0 & aop1_4=0b001 & aop4_8=0b1111 & aaxh0 {}
a_opp:aaxl0, aaxh0 is aaxl0 & aop1_4=0b001 & aop4_8=0b1111 & aaxh0 {
	prod = prod + (sext(aaxl0) * sext(aaxh0));
}

a_opc:"LSR16" is aacf0 & aop1_4=0b010 & aop4_8=0b1111 {}
a_opp:aacf0   is aacf0 & aop1_4=0b010 & aop4_8=0b1111 {
	aacf0 = aacf0 >> 16;
	FLAGS40(aacf0);
}

a_opc:"MSUB"       is aaxl0 & aop1_4=0b011 & aop4_8=0b1111 & aaxh0 {}
a_opp:aaxl0, aaxh0 is aaxl0 & aop1_4=0b011 & aop4_8=0b1111 & aaxh0 {
	prod = prod - (sext(aaxl0) * sext(aaxh0));
}

a_opc:"ADDPAXZ"    is aacf0 & aaxf1 & aop2_4=0b10 & aop4_8=0b1111 {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 & aop2_4=0b10 & aop4_8=0b1111 {
	oldprod:5 = prod;
	# TODO: Does the masking happen before or after?
	# i.e. do prod.l and ax0.l/ax1.l affect the result?
	aacf0 = (prod + sext(aaxf1)) & 0xffffffff0000;
	# TODO: Why doesn't this set the overflow bit?
	FLAGS40X(aacf0, oldprod > aacf0, 0);
}

a_opc:"CLRL" is aacl0 & aop1_4=0b110 & aop4_8=0b1111 & aacf0 {}
a_opp:aacl0  is aacl0 & aop1_4=0b110 & aop4_8=0b1111 & aacf0 {
	# TODO: This should be round-to-even
	aacl0 = 0;
	FLAGS40(aacf0);
}

a_opc:"MOVPZ" is aacf0 & aop1_4=0b111 & aop4_8=0b1111 {}
a_opp:aacf0   is aacf0 & aop1_4=0b111 & aop4_8=0b1111 {
	aacf0 = prod & 0xffffffff0000;
	FLAGS40(aacf0);
}

# Define extension opcodes and opcode parameters.
# We use two tables: ext_opc0 for bit 7 (axbit) being set to 0, and ext_opc1 for bit 7 being 1.
# This is so that arithmetic opcodes with aop4_8=0b0011 can be implemented correctly;
# they only have 7 bits of the extension opcode and treat the top bit as 0.

# There is no extension instruction with xop2_4=0 and xop4_8=0.

ext_opc0:"DR"   is xar0_2 & xop2_4=1 & xop4_7=0 {}
ext_opp0:xar0_2 is xar0_2 & xop2_4=1 & xop4_7=0 { xar0_2 = xar0_2 - 1; }

ext_opc0:"IR"   is xar0_2 & xop2_4=2 & xop4_7=0 {}
ext_opp0:xar0_2 is xar0_2 & xop2_4=2 & xop4_7=0 { xar0_2 = xar0_2 + 1; }

# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
ext_opc0:"NR"           is xar0_2 & xop2_4=3 & xop4_7=0 & xix0_2 {}
ext_opp0:xar0_2, xix0_2 is xar0_2 & xop2_4=3 & xop4_7=0 & xix0_2 { xar0_2 = xar0_2 + xix0_2; }

ext_opc0:"MV"           is xac0_2 & xax2_4 & xop4_7=1 {}
ext_opp0:xax2_4, xac0_2 is xac0_2 & xax2_4 & xop4_7=1 & saturated_xac0_2 { xax2_4 = saturated_xac0_2; }

ext_opc0:"L"                is xar0_2 & xop2=0 & xac3_6 & xop6=1 {}
ext_opp0:xac3_6, "@"^xar0_2 is xar0_2 & xop2=0 & xac3_6 & xop6=1 & sign_extend_xac3_6_after { xac3_6 = *:2 xar0_2; xar0_2 = xar0_2 + 1; build sign_extend_xac3_6_after; }

# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
ext_opc0:"LN"                       is xar0_2 & xix0_2 & xop2=1 & xac3_6 & xop6=1 {}
ext_opp0:xac3_6, "@"^xar0_2, xix0_2 is xar0_2 & xix0_2 & xop2=1 & xac3_6 & xop6=1 & sign_extend_xac3_6_after { xac3_6 = *:2 xar0_2; xar0_2 = xar0_2 + xix0_2; build sign_extend_xac3_6_after; }

ext_opc1:"LS"          is xacm0 & xop1=0 & xop2_4=0 & xax4_6 & xop6=0 {}
ext_opp1:xax4_6, xacm0 is xacm0 & xop1=0 & xop2_4=0 & xax4_6 & xop6=0 & saturated_xacm0 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = saturated_xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + 1;
}

ext_opc1:"LSN"         is xacm0 & xop1=0 & xop2_4=1 & xax4_6 & xop6=0 {}
ext_opp1:xax4_6, xacm0 is xacm0 & xop1=0 & xop2_4=1 & xax4_6 & xop6=0 & saturated_xacm0 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = saturated_xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + 1;
}

ext_opc1:"LSM"         is xacm0 & xop1=0 & xop2_4=2 & xax4_6 & xop6=0 {}
ext_opp1:xax4_6, xacm0 is xacm0 & xop1=0 & xop2_4=2 & xax4_6 & xop6=0 & saturated_xacm0 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = saturated_xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + ix3;
}

ext_opc1:"LSNM"        is xacm0 & xop1=0 & xop2_4=3 & xax4_6 & xop6=0 {}
ext_opp1:xax4_6, xacm0 is xacm0 & xop1=0 & xop2_4=3 & xax4_6 & xop6=0 & saturated_xacm0 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = saturated_xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + ix3;
}

ext_opc0:"S"                is xar0_2 & xop2=0 & xac3_5 & xop5=1 & xop6=0 {}
ext_opp0:"@"^xar0_2, xac3_5 is xar0_2 & xop2=0 & xac3_5 & xop5=1 & xop6=0 & saturated_xac3_5 { *:2 xar0_2 = saturated_xac3_5; xar0_2 = xar0_2 + 1; }

# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
ext_opc0:"SN"                       is xar0_2 & xop2=1 & xac3_5 & xop5=1 & xop6=0 & xix0_2 {}
ext_opp0:"@"^xar0_2, xac3_5, xix0_2 is xar0_2 & xop2=1 & xac3_5 & xop5=1 & xop6=0 & xix0_2 & saturated_xac3_5 { *:2 xar0_2 = saturated_xac3_5; xar0_2 = xar0_2 + xix0_2; }

ext_opc1:"SL"          is xacm0 & xop1=1 & xop2_4=0 & xax4_6 & xop6=0 {}
ext_opp1:xacm0, xax4_6 is xacm0 & xop1=1 & xop2_4=0 & xax4_6 & xop6=0 & saturated_xacm0 {
	xax4_6 = *:2 ar3;
	*:2 ar0 = saturated_xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + 1;
}

ext_opc1:"SLN"         is xacm0 & xop1=1 & xop2_4=1 & xax4_6 & xop6=0 {}
ext_opp1:xacm0, xax4_6 is xacm0 & xop1=1 & xop2_4=1 & xax4_6 & xop6=0 & saturated_xacm0 {
	xax4_6 = *:2 ar3;
	*:2 ar0 = saturated_xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + 1;
}

ext_opc1:"SLM"         is xacm0 & xop1=1 & xop2_4=2 & xax4_6 & xop6=0 {}
ext_opp1:xacm0, xax4_6 is xacm0 & xop1=1 & xop2_4=2 & xax4_6 & xop6=0 & saturated_xacm0 {
	xax4_6 = *:2 ar3;
	*:2 ar0 = saturated_xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + ix3;
}

ext_opc1:"SLNM"        is xacm0 & xop1=1 & xop2_4=3 & xax4_6 & xop6=0 {}
ext_opp1:xacm0, xax4_6 is xacm0 & xop1=1 & xop2_4=3 & xax4_6 & xop6=0 & saturated_xacm0 {
	xax4_6 = *:2 ar3;
	*:2 ar0 = saturated_xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + ix3;
}

# LD loads to both AX0 and AX1, with the instruction choosing separately for AX0.l vs AX0.h and AX1.l vs AX1.h.
# ax0 is set to the memory value pointed by a choice of AR0/1/2, while ax1 is set to the memory value pointed by AR3.
# AR3 cannot be used for the first value, as that encodes LDAX instead.  The address registers are increased by 1 or
# the corresponding index register (depending on M/N like the other extension instructions).
ext_opc1:"LD"                         is xar0_2 & xop2_4=0 & xax1lh4 & xax0lh5 & xop6=1 {}
ext_opp1:xax0lh5, xax1lh4, "@"^xar0_2 is xar0_2 & xop2_4=0 & xax1lh4 & xax0lh5 & xop6=1 {
	xax0lh5 = *:2 xar0_2;
	xax1lh4 = *:2 ar3;
	xar0_2 = xar0_2 + 1;
	ar3 = ar3 + 1;
}

# LDAX sets ax0.h or ax1.h to the memory value pointed by either AR0 or AR1, and
# ax0.l or ax1.l to the memory value pointed by AR3.  The choice is either both
# ax0.h and ax0.l or ax1.h and ax1.l.  AR2 cannot be used.  M/N exist like normal.
ext_opc1:"LDAX"         is xop0_2=3 & xop2_4=0 & xax4 & xar5 & xop6=1 & xaxl4 & xaxh4 {}
ext_opp1:xax4, "@"^xar5 is xop0_2=3 & xop2_4=0 & xax4 & xar5 & xop6=1 & xaxl4 & xaxh4 {
	xaxh4 = *:2 xar5;
	xaxl4 = *:2 ar3;
	xar5 = xar5 + 1;
	ar3 = ar3 + 1;
}

# xar0_2 and xix0_2 are the same bits in the instruction.  I haven't included it here (or in LDNM).
ext_opc1:"LDN"                        is xar0_2 & xop2_4=1 & xax1lh4 & xax0lh5 & xop6=1 & xix0_2 {}
ext_opp1:xax0lh5, xax1lh4, "@"^xar0_2 is xar0_2 & xop2_4=1 & xax1lh4 & xax0lh5 & xop6=1 & xix0_2 {
	xax0lh5 = *:2 xar0_2;
	xax1lh4 = *:2 ar3;
	xar0_2 = xar0_2 + xix0_2;
	ar3 = ar3 + 1;
}

ext_opc1:"LDAXN"        is xop0_2=3 & xop2_4=1 & xax4 & xar5 & xop6=1 & xaxl4 & xaxh4 & xix5 {}
ext_opp1:xax4, "@"^xar5 is xop0_2=3 & xop2_4=1 & xax4 & xar5 & xop6=1 & xaxl4 & xaxh4 & xix5 {
	xaxh4 = *:2 xar5;
	xaxl4 = *:2 ar3;
	xar5 = xar5 + xix5;
	ar3 = ar3 + 1;
}

ext_opc1:"LDM"                        is xar0_2 & xop2_4=2 & xax1lh4 & xax0lh5 & xop6=1 {}
ext_opp1:xax0lh5, xax1lh4, "@"^xar0_2 is xar0_2 & xop2_4=2 & xax1lh4 & xax0lh5 & xop6=1 {
	xax0lh5 = *:2 xar0_2;
	xax1lh4 = *:2 ar3;
	xar0_2 = xar0_2 + 1;
	ar3 = ar3 + ix3;
}

ext_opc1:"LDAXM"        is xop0_2=3 & xop2_4=2 & xax4 & xar5 & xop6=1 & xaxl4 & xaxh4 {}
ext_opp1:xax4, "@"^xar5 is xop0_2=3 & xop2_4=2 & xax4 & xar5 & xop6=1 & xaxl4 & xaxh4 {
	xaxh4 = *:2 xar5;
	xaxl4 = *:2 ar3;
	xar5 = xar5 + 1;
	ar3 = ar3 + ix3;
}

ext_opc1:"LDNM"                       is xar0_2 & xop2_4=3 & xax1lh4 & xax0lh5 & xop6=1 & xix0_2 {}
ext_opp1:xax0lh5, xax1lh4, "@"^xar0_2 is xar0_2 & xop2_4=3 & xax1lh4 & xax0lh5 & xop6=1 & xix0_2 {
	xax0lh5 = *:2 xar0_2;
	xax1lh4 = *:2 ar3;
	xar0_2 = xar0_2 + xix0_2;
	ar3 = ar3 + ix3;
}

ext_opc1:"LDAXNM"       is xop0_2=3 & xop2_4=3 & xax4 & xar5 & xop6=1 & xaxl4 & xaxh4 & xix5 {}
ext_opp1:xax4, "@"^xar5 is xop0_2=3 & xop2_4=3 & xax4 & xar5 & xop6=1 & xaxl4 & xaxh4 & xix5 {
	xaxh4 = *:2 xar5;
	xaxl4 = *:2 ar3;
	xar5 = xar5 + xix5;
	ar3 = ar3 + ix3;
}

ext_opc:ext_opc0 is ext_opc0 & (axbit=0 | aop4_8=0b0011) {}
ext_opp:ext_opp0 is ext_opp0 & (axbit=0 | aop4_8=0b0011) { build ext_opp0; }

ext_opc:ext_opc1 is ext_opc1 & (axbit=1 & aop4_8!=0b0011) {}
ext_opp:ext_opp1 is ext_opp1 & (axbit=1 & aop4_8!=0b0011) { build ext_opp1; }

# Combine arithmetic ops and extension ops
op:^a_opc^"'"^ext_opc a_opp ":" ext_opp is a_opc & a_opp & ext_opc & ext_opp { build a_opp; build ext_opp; }

# If the extension opcode is set to 0, it seems like it's a NOP.
# We could explicitly show 'NOP here, but that just adds noise for no benefit.
op:^a_opc a_opp is a_opc & a_opp & (axbit=0 | aop4_8=0b0011) & xop0_7=0 { build a_opp; }

LoopSkipAddrWrapper: loopskipaddr is loopskipaddr { export *[inst]:2 loopskipaddr; }
LoopJumpBackAddrWrapper: loopjumpbackaddr is loopjumpbackaddr { export *[inst]:2 loopjumpbackaddr; }

# Regular ops
loopcheck:^op is hasloopcheck=0 & op { build op; }
loopcheck:^op is hasloopcheck=1 & op & LoopSkipAddrWrapper {
	if (st3 == 0) goto LoopSkipAddrWrapper;

	st3 = st3 - 1;
	build op;
}
:^loopcheck is hasloopjumpback=0 & loopcheck { build loopcheck; }
:^loopcheck is hasloopjumpback=1 & loopcheck & LoopJumpBackAddrWrapper {
	build loopcheck;
	goto LoopJumpBackAddrWrapper;
}
