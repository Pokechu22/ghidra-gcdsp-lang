# sleigh specification file for Intel 8085

define endian=little;
define alignment=2;

define space ram      type=ram_space      size=2 wordsize=2 default;
define space register type=register_space size=1 wordsize=2;

define register offset=0x00 size=2 [ ar0 ar1 ar2 ar3 ]; # Addressing registers
define register offset=0x08 size=2 [ ix0 ix1 ix2 ix3 ]; # Indexing registers
define register offset=0x10 size=2 [ r08 r09 r0A r0B ]; # Not listed with separate names
define register offset=0x18 size=2 [ st0 st1 st2 st3 ]; # Stack-related registers
define register offset=0x20 size=2 [ ac0.h ac1.h ]; # 40-bit accumulators
define register offset=0x24 size=2 [ config sr ];
define register offset=0x28 size=2 [ prod.l prod.m1 prod.h prod.m2 ]; # Product
define register offset=0x30 size=2 [ ax0.l ax0.h ax1.l ax1.h ]; # 32-bit accumulators
define register offset=0x38 size=2 [ ac0.l ac1.l ac0.m ac1.m ]; # 40-bit accumulators

define token opbyte (16)
	op0_4  = (0, 3)
	op3_8  = (3, 7)
	op4_8  = (4, 7)
	op5_8  = (5, 7)
	op6_8  = (6, 7)
	op8_16 = (8, 15)
	op9_16 = (9, 15)
	op11_16 = (11, 15)

	reg0_5 = (0, 4)

	ar0_2 = (0, 1)

	ix2_4 = (2, 3)
	op2_4 = (2, 3)

	cc0_4 = (0, 3)

	acm8 = (8, 8)
	ac8_11 = (8, 10)

	imm3 = (0, 2)
	imm6 = (0, 5)

	imm8 = (0, 7)
	simm8 = (0, 7) signed
;

Imm3: "#"^imm3 is imm3 { export imm3; }
Imm6: "#"^imm6 is imm6 { export imm6; }

Imm8: "#"^imm8 is imm8 { export imm8; }
SImm8: "#"^simm8 is simm8 { export simm8; }

define token data16 (16)
   imm16  = (0,15)
   simm16 = (0,15) signed
;

Addr16: imm16 is imm16 { export imm16; }
Imm16: "#"^imm16 is imm16 { export imm16; }
SImm16: "#"^simm16 is simm16 { export simm16; }
Mem16: "@"^imm16 is imm16 { export *:2 imm16; }

attach variables [ reg0_5 ] [
	ar0 ar1 ar2 ar3
	ix0 ix1 ix2 ix3
	r08 r09 r0A r0B
	st0 st1 st2 st3
	ac0.h ac1.h
	config sr
	prod.l prod.m1 prod.h prod.m2
	ax0.l ax0.h ax1.l ax1.h
	ac0.l ac1.l ac0.m ac1.m
];

attach variables [ ar0_2 ] [ ar0 ar1 ar2 ar3 ];
attach variables [ ix2_4 ] [ ix0 ix1 ix2 ix3 ];

attach variables [ acm8 ] [ ac0.m ac1.m ]; # Middle of 40-bit accumulators
attach variables [ ac8_11 ] [ ax0.l ax0.h ax1.l ax1.h ac0.l ac1.l ac0.m ac1.m ]; # 3-bit field referring to a register starting at 0x18 (ax0.l)

macro FLAGS(result) {
	sr[0,1] = 0;  # TODO: Carry
	sr[1,1] = 0;  # TODO: Overflow
	sr[2,1] = (result == 0);  # Zero
	sr[3,1] = (result < 0);  # Sign
	sr[4,1] = 0;  # TODO: Above s32
	sr[5,1] = 0;  # TODO: Top 2 bits equal
	sr[6,1] = 0;  # TODO: Logic zero
	sr[7,1] = 0;  # TODO: Overflow (sticky)
}

:NOP is op0_4=0 & op4_8=0 & op8_16=0 {
}

:DAR ar0_2 is ar0_2 & op2_4=0b01 & op4_8=0 & op8_16=0 {
	ar0_2 = ar0_2 - 1;
}

:IAR ar0_2 is ar0_2 & op2_4=0b10 & op4_8=0 & op8_16=0 {
	ar0_2 = ar0_2 - 1;
}

# No instruction with op2_4=0b11 & op4_8=0 & op8_16=0

:IAR ar0_2, ix2_4 is ar0_2 & ix2_4 & op4_8=0b0001 & op8_16=0 {
	ar0_2 = ar0_2 + ix2_4;
}

:HALT is op0_4=0b0001 & op4_8=0b0010 & op8_16=0 unimpl

:LOOP reg0_5          is reg0_5 & op5_8=0b010 & op8_16=0 unimpl
:BLOOP reg0_5, Addr16 is reg0_5 & op5_8=0b011 & op8_16=0; Addr16 unimpl

:LRI reg0_5, Imm16 is reg0_5 & op5_8=0b100 & op8_16=0; Imm16 {
	reg0_5 = Imm16;
	# "Perform an additional operation depending on destination register"
}

# No instruction with op5_8=0b101 & op8_16=0

:LR reg0_5, Mem16 is reg0_5 & op5_8=0b110 & op8_16=0; Mem16 {
	reg0_5 = Mem16;
	# "Perform an additional operation depending on destination register"
}

:SR reg0_5, Mem16 is reg0_5 & op5_8=0b111 & op8_16=0; Mem16 {
	Mem16 = reg0_5;
	# "Perform an additional operation depending on destination register"
}

cc: "GE" is cc0_4=0b0000 unimpl
cc: "L"  is cc0_4=0b0001 unimpl
cc: "G"  is cc0_4=0b0010 unimpl
cc: "LE" is cc0_4=0b0011 unimpl
cc: "NE" is cc0_4=0b0100 { c:1 = ((sr & 0x04) == 0); export c; }
cc: "EQ" is cc0_4=0b0101 { c:1 = ((sr & 0x04) != 0); export c; }
cc: "NC" is cc0_4=0b0110 { c:1 = ((sr & 0x01) == 0); export c; }
cc: "C"  is cc0_4=0b0111 { c:1 = ((sr & 0x01) != 0); export c; }
cc: "x8" is cc0_4=0b1000 { c:1 = ((sr & 0x10) == 0); export c; } # "Below s32"
cc: "x9" is cc0_4=0b1001 { c:1 = ((sr & 0x10) != 0); export c; } # "Above s32"
cc: "xA" is cc0_4=0b1010 unimpl
cc: "xB" is cc0_4=0b1011 unimpl
cc: "NZ" is cc0_4=0b1100 { c:1 = ((sr & 0x40) != 0); export c; }
cc: "ZR" is cc0_4=0b1111 { c:1 = ((sr & 0x40) != 0); export c; }
cc: "O"  is cc0_4=0b1110 { c:1 = ((sr & 0x02) != 0); export c; }
# The always variant (cc0_4=0b1111) isn't listed here, so it can be handled separately

:IF^cc is cc & op8_16=2 unimpl
# if (!cc) goto inst_next;

:J^cc Addr16 is cc & op4_8=0b1001 & op8_16=2; Addr16 {
	if (!cc) goto inst_next;
	goto Addr16;
}

:J^cc Addr16 is cc & op4_8=0b1011 & op8_16=2; Addr16 {
	# TODO: Update stack
	if (!cc) goto inst_next;
	call Addr16;
}

:RET^cc is cc & op4_8=0b1101 & op8_16=2 {
	if (!cc) goto inst_next;

	tmp:2 = 0; # TODO: Return address
	return [tmp];
}

# Unconditional variants

# Unconditionally execute the next opcode, presumably... not very useful?  Mark as unimpl so that a warning occurs
:IF is cc0_4=0b1111 & op4_8=0b0111 & op8_16=2 unimpl

:JMP Addr16 is cc0_4=0b1111 & op4_8=0b1001 & op8_16=2; Addr16 {
	goto Addr16;
}

:CALL Addr16 is cc0_4=0b1111 & op4_8=0b1011 & op8_16=2; Addr16 {
	# TODO: Update stack
	call Addr16;
}

:RET is cc0_4=0b1111 & op4_8=0b1101 & op8_16=2 {
	tmp:2 = 0; # TODO: Return address
	return [tmp];
}

:ADDI  acm8, SImm16 is op0_4=0 & op4_8=0b0000 & acm8 & op9_16=1; SImm16 unimpl
:XORI  acm8, SImm16 is op0_4=0 & op4_8=0b0010 & acm8 & op9_16=1; SImm16 unimpl
:ANDI  acm8, SImm16 is op0_4=0 & op4_8=0b0100 & acm8 & op9_16=1; SImm16 unimpl
:ORI   acm8, SImm16 is op0_4=0 & op4_8=0b0110 & acm8 & op9_16=1; SImm16 unimpl
:CMPI  acm8, SImm16 is op0_4=0 & op4_8=0b1000 & acm8 & op9_16=1; SImm16 unimpl
:ANDCF acm8, SImm16 is op0_4=0 & op4_8=0b1010 & acm8 & op9_16=1; SImm16 unimpl
:ANDF  acm8, SImm16 is op0_4=0 & op4_8=0b1100 & acm8 & op9_16=1; SImm16 unimpl

:ILLR acm8, "@"^ar0_2 is ar0_2 & op2_4=0 & op4_8=1 & acm8 & op9_16=1 {
	acm8 = *:2 ar0_2;
}

# "Perform an additional operation depending on destination register"
:ADDIS acm8, SImm8 is SImm8 & acm8 & op9_16=0b0000010 unimpl
:CMPIS acm8, SImm8 is SImm8 & acm8 & op9_16=0b0000011 unimpl
:LRIS ac8_11, SImm8 is SImm8 & ac8_11 & op11_16=0b00001 {
	ac8_11 = SImm8;
}

:LOOPI Imm8 is Imm8 & op8_16=0b00010000 unimpl
:BLOOPI Imm8, Addr16 is Imm8 & op8_16=0b00010001; Addr16 unimpl

# op3_8 is marked as ????? in the table but shown as 0s for the instruction itself
# TODO: Could maybe specify what the bit is with a name
:SBSET Imm3 is Imm3 & op3_8=0 & op8_16=0b00010010 {
	sr = sr | 1 << (6 + Imm3);
}
:SBCLR Imm3 is Imm3 & op3_8=0 & op8_16=0b00010011 {
	sr = sr & ~(1 << (6 + Imm3));
}

# The manual is written such that it implies LSL/LSR and ASL/ASR are the same instruction with a 7-bit signed immediate value,
# though it treats them as 2 pairs of instructions with a 6-bit value (allegedly somehow sign-extended for the right-shift)
:LSL acm8, Imm6 is Imm6 & op6_8=0b00 & acm8 & op9_16=0b0001010 unimpl
:ASR acm8, Imm6 is Imm6 & op6_8=0b01 & acm8 & op9_16=0b0001010 unimpl
:LSL acm8, Imm6 is Imm6 & op6_8=0b10 & acm8 & op9_16=0b0001010 unimpl
:ASR acm8, Imm6 is Imm6 & op6_8=0b11 & acm8 & op9_16=0b0001010 unimpl
