# sleigh specification file for GameCube DSP

define endian=big;
define alignment=2;

define space ram      type=ram_space      size=2 wordsize=2 default;
define space register type=register_space size=1 wordsize=2;

define register offset=0x00 size=2 [ ar0 ar1 ar2 ar3 ]; # Addressing registers
define register offset=0x08 size=2 [ ix0 ix1 ix2 ix3 ]; # Indexing registers
define register offset=0x10 size=2 [ r08 r09 r0A r0B ]; # Not listed with separate names
define register offset=0x18 size=2 [ st0 st1 st2 st3 ]; # Stack-related registers
#define register offset=0x20 size=2 [ ac0.h ac1.h ]; # 40-bit accumulators
define register offset=0x24 size=2 [ config sr ];
define register offset=0x28 size=2 [ prod.l prod.m1 prod.h prod.m2 ]; # Product
#define register offset=0x30 size=2 [ ax0.l ax0.h ax1.l ax1.h ]; # 32-bit accumulators
#define register offset=0x38 size=2 [ ac0.l ac1.l ac0.m ac1.m ]; # 40-bit accumulators

# Fake versions of the accumulator registers to make emulating them reasonable
define register offset=0x80 size=2 [ ac0.l ac0.m ac0.h ];
define register offset=0x80 size=6 [ ac0 ];
define register offset=0x80 size=4 [ acs0 ]; # Short/mid accumulator, 24 bits
define register offset=0x90 size=2 [ ac1.l ac1.m ac1.h ];
define register offset=0x90 size=6 [ ac1 ];
define register offset=0x90 size=4 [ acs1 ]; # Short/mid accumulator, 24 bits
define register offset=0xA0 size=2 [ ax0.l ax0.h ];
define register offset=0xA0 size=6 [ ax0 ];
define register offset=0xB0 size=2 [ ax1.l ax1.h ];
define register offset=0xB0 size=6 [ ax1 ];

define token opbyte (16)
	op0_4  = (0, 3)
	op3_8  = (3, 7)
	op4_8  = (4, 7)
	op5_8  = (5, 7)
	op6_8  = (6, 7)
	op7_9  = (7, 8)
	op8_16 = (8, 15)
	op9_16 = (9, 15)
	op10_16 = (10, 15)
	op11_16 = (11, 15)

	op0_5  = (0, 4)

	ar0_2 = (0, 1)

	ix2_4 = (2, 3)
	op2_4 = (2, 3)

	reg0_5 = (0, 4)

	ar5_7 = (5, 6)
	ix5_7 = (5, 6)

	reg5_8 = (5, 7)
	reg5_10 = (5, 9)

	cc0_4 = (0, 3)

	acm8 = (8, 8)
	acf8 = (8, 8)
	acs8 = (8, 8)
	ac8_11 = (8, 10)

	imm3 = (0, 2)
	imm6 = (0, 5)

	imm8 = (0, 7)
	simm8 = (0, 7) signed
;

Imm3: "#"^imm3 is imm3 { export imm3; }
Imm6: "#"^imm6 is imm6 { export imm6; }

Imm8: "#"^imm8 is imm8 { export imm8; }
SImm8: "#"^simm8 is simm8 { export simm8; }
Mem8: "@"^simm8 is simm8 { export *:2 simm8; }  # TODO: Is this formatted right?

define token data16 (16)
	imm16  = (0,15)
	simm16 = (0,15) signed
;

Addr16: imm16 is imm16 { export *:1 imm16; }
Imm16: "#"^imm16 is imm16 { export imm16; }
SImm16: "#"^simm16 is simm16 { export simm16; }
Mem16: "@"^imm16 is imm16 { export *:2 imm16; }

attach variables [ reg0_5 reg5_10 ] [
	ar0 ar1 ar2 ar3
	ix0 ix1 ix2 ix3
	r08 r09 r0A r0B
	st0 st1 st2 st3
	ac0.h ac1.h
	config sr
	prod.l prod.m1 prod.h prod.m2
	ax0.l ax0.h ax1.l ax1.h
	ac0.l ac1.l ac0.m ac1.m
];

attach variables [ ar0_2 ar5_7 ] [ ar0 ar1 ar2 ar3 ];
attach variables [ ix2_4 ix5_7 ] [ ix0 ix1 ix2 ix3 ];

attach variables [ reg5_8 ] [ ar0 ar1 ar2 ar3 ix0 ix1 ix2 ix3 ]; # TODO: This is a guess

attach variables [ acm8 ] [ ac0.m ac1.m ]; # Middle of 40-bit accumulators
attach variables [ acf8 ] [ ac0 ac1 ]; # Full 40-bit accumulators
attach variables [ acs8 ] [ acs0 acs1 ]; # 24 bits of 40-bit accumulators
attach variables [ ac8_11 ] [ ax0.l ax0.h ax1.l ax1.h ac0.l ac1.l ac0.m ac1.m ]; # 3-bit field referring to a register starting at 0x18 (ax0.l)

# Opbyte for arithmetic instructions
define token aopbyte (8)
	aop0_8 = (0, 7)
	aop4_8 = (4, 7)
	aop5_8 = (5, 7)
	aop2_4 = (2, 3)
	aop1 = (1, 1)
	aop3 = (3, 3)
	aop0_3 = (0, 2)
	aop1_4 = (1, 3)
	aop1_3 = (1, 2)

	aacl0 = (0, 0) # Low part of 40-bit accumulator

	aacm0 = (0, 0) # Middle of 40-bit accumulator
	aacm1 = (1, 1) # Middle of 40-bit accumulator
	aacm0_other = (0, 0) # Middle of 40-bit accumulator, backwards
	aacm4 = (4, 4) # Middle of 40-bit accumulator

	aacf0 = (0, 0) # Full 40 bits of an accumulator
	aacf0_other = (0, 0) # Full 40 bits of an accumulator, backwards
	aacf3 = (3, 3) # Full 40 bits of an accumulator

	aacs0 = (0, 0) # 24 bits of a 40-bit accumulator

	aaxh0 = (0, 0) # High bits of 32-bit accumulator
	aaxh1 = (1, 1) # High bits of 32-bit accumulator
	aaxh3 = (3, 3) # High bits of 32-bit accumulator
	aaxl0 = (0, 0) # Low bits of 32-bit accumulator
	aaxl1 = (1, 1) # Low bits of 32-bit accumulator
	aaxl3 = (3, 3) # Low bits of 32-bit accumulator
	aaxf1 = (1, 1) # Full 32 bits of an accumulator
	aax1_2 = (1, 2) # 32-bit accumulator

	aax0lh1 = (1, 1) # Either ax0.l or ax0.h
	aax0lh4 = (4, 4) # Either ax0.l or ax0.h
	aax1lh0 = (0, 0) # Either ax1.l or ax1.h
	aax1lh3 = (3, 3) # Either ax1.l or ax1.h
;

attach variables [ aacl0 ] [ ac0.l ac1.l ];
attach variables [ aacm0 aacm1 aacm4 ] [ ac0.m ac1.m ];
attach variables [ aacm0_other ] [ ac1.m ac0.m ];
attach variables [ aacf0 aacf3 ] [ ac0 ac1 ];
attach variables [ aacf0_other ] [ ac0 ac1 ];
attach variables [ aacs0 ] [ acs0 acs1 ];
attach variables [ aaxh0 aaxh1 aaxh3 ] [ ax0.h ax1.h ];
attach variables [ aaxl0 aaxl1 aaxl3 ] [ ax0.l ax1.l ];
attach variables [ aax1_2 ] [ ax0.l ax0.h ax1.l ax1.h ]; # 2-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ aaxf1 ] [ ax0 ax1 ];

attach variables [ aax0lh1 aax0lh4 ] [ ax0.l ax0.h ];
attach variables [ aax1lh0 aax1lh3 ] [ ax1.l ax1.h ];

# Opbyte for extension instructions - TODO: less horrible names
define token xopbyte (8)
	xop0_8 = (0, 7)
	xop4_8 = (4, 7)
	xop6_8 = (6, 7)
	xop1   = (1, 1)
	xop2   = (2, 2)
	xop5   = (5, 5)
	xop2_4 = (2, 3)

	xar0_2 = (0, 1) # Addressing register
	xix0_2 = (0, 1) # Index register
	xac3_6 = (3, 5) # Either accumulator
	xax2_4 = (2, 3) # 32-bit accumulator
	xax4_6 = (4, 5) # 32-bit accumulator
	xac0_2 = (0, 1) # 40-bit accumulator
	xac3_5 = (3, 4) # 40-bit accumulator
	xac4_6 = (4, 5) # 40-bit accumulator
	xacm0  = (0, 0) # Either ac0.m or ac1.m
;

attach variables [ xar0_2 ] [ ar0 ar1 ar2 ar3 ];
attach variables [ xix0_2 ] [ ix0 ix1 ix2 ix3 ];
attach variables [ xac3_6 ] [ ax0.l ax0.h ax1.l ax1.h ac0.l ac1.l ac0.m ac1.m ]; # 3-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ xax2_4 xax4_6 ] [ ax0.l ax0.h ax1.l ax1.h ]; # 2-bit field referring to a register starting at 0x18 (ax0.l)
attach variables [ xac0_2 xac3_5 xac4_6 ] [ ac0.l ac1.l ac0.m ac1.m ]; # 2-bit field referring to a register starting at 0x1C (ac0.l)
attach variables [ xacm0 ] [ ac0.m ac1.m ];

macro FLAGS(result) {
	sr[0,1] = 0;  # TODO: Carry
	sr[1,1] = 0;  # TODO: Overflow
	sr[2,1] = (result == 0);  # Zero
	sr[3,1] = (result s< 0);  # Sign
	sr[4,1] = 0;  # TODO: Above s32
	sr[5,1] = 0;  # TODO: Top 2 bits equal
	sr[6,1] = 0;  # TODO: Logic zero
	sr[7,1] = 0;  # TODO: Overflow (sticky)
}

:NOP is op0_4=0 & op4_8=0 & op8_16=0 {
}

:DAR ar0_2 is ar0_2 & op2_4=0b01 & op4_8=0 & op8_16=0 {
	ar0_2 = ar0_2 - 1;
}

:IAR ar0_2 is ar0_2 & op2_4=0b10 & op4_8=0 & op8_16=0 {
	ar0_2 = ar0_2 - 1;
}

# No instruction with op2_4=0b11 & op4_8=0 & op8_16=0

:IAR ar0_2, ix2_4 is ar0_2 & ix2_4 & op4_8=0b0001 & op8_16=0 {
	ar0_2 = ar0_2 + ix2_4;
}

:HALT is op0_4=0b0001 & op4_8=0b0010 & op8_16=0 unimpl

:LOOP reg0_5          is reg0_5 & op5_8=0b010 & op8_16=0 unimpl
:BLOOP reg0_5, Addr16 is reg0_5 & op5_8=0b011 & op8_16=0; Addr16 unimpl

:LRI reg0_5, Imm16 is reg0_5 & op5_8=0b100 & op8_16=0; Imm16 {
	reg0_5 = Imm16;
	# "Perform an additional operation depending on destination register"
}

# No instruction with op5_8=0b101 & op8_16=0

:LR reg0_5, Mem16 is reg0_5 & op5_8=0b110 & op8_16=0; Mem16 {
	reg0_5 = Mem16;
	# "Perform an additional operation depending on destination register"
}

:SR reg0_5, Mem16 is reg0_5 & op5_8=0b111 & op8_16=0; Mem16 {
	Mem16 = reg0_5;
	# "Perform an additional operation depending on destination register"
}

cc: "GE" is cc0_4=0b0000 unimpl
cc: "L"  is cc0_4=0b0001 unimpl
cc: "G"  is cc0_4=0b0010 unimpl
cc: "LE" is cc0_4=0b0011 unimpl
cc: "NE" is cc0_4=0b0100 { c:1 = ((sr & 0x04) == 0); export c; }
cc: "EQ" is cc0_4=0b0101 { c:1 = ((sr & 0x04) != 0); export c; }
cc: "NC" is cc0_4=0b0110 { c:1 = ((sr & 0x01) == 0); export c; }
cc: "C"  is cc0_4=0b0111 { c:1 = ((sr & 0x01) != 0); export c; }
cc: "x8" is cc0_4=0b1000 { c:1 = ((sr & 0x10) == 0); export c; } # "Below s32"
cc: "x9" is cc0_4=0b1001 { c:1 = ((sr & 0x10) != 0); export c; } # "Above s32"
cc: "xA" is cc0_4=0b1010 unimpl
cc: "xB" is cc0_4=0b1011 unimpl
cc: "NZ" is cc0_4=0b1100 { c:1 = ((sr & 0x40) == 0); export c; }
cc: "ZR" is cc0_4=0b1101 { c:1 = ((sr & 0x40) != 0); export c; }
cc: "O"  is cc0_4=0b1110 { c:1 = ((sr & 0x02) != 0); export c; }
# The always variant (cc0_4=0b1111) isn't listed here, so it can be handled separately

:IF^cc is cc & op8_16=2 unimpl
# if (!cc) goto inst_next;

:J^cc Addr16 is cc & op4_8=0b1001 & op8_16=2; Addr16 {
	if (!cc) goto inst_next;
	goto Addr16;
}

:CALL^cc Addr16 is cc & op4_8=0b1011 & op8_16=2; Addr16 {
	# TODO: Update stack
	if (!cc) goto inst_next;
	call Addr16;
}

:RET^cc is cc & op4_8=0b1101 & op8_16=2 {
	if (!cc) goto inst_next;

	tmp:2 = 0; # TODO: Return address
	return [tmp];
}

# Unconditional variants

# Unconditionally execute the next opcode, presumably... not very useful?  Mark as unimpl so that a warning occurs
:IF is cc0_4=0b1111 & op4_8=0b0111 & op8_16=2 unimpl

:JMP Addr16 is cc0_4=0b1111 & op4_8=0b1001 & op8_16=2; Addr16 {
	goto Addr16;
}

:CALL Addr16 is cc0_4=0b1111 & op4_8=0b1011 & op8_16=2; Addr16 {
	# TODO: Update stack
	call Addr16;
}

:RET is cc0_4=0b1111 & op4_8=0b1101 & op8_16=2 {
	tmp:2 = 0; # TODO: Return address
	return [tmp];
}

:ADDI  acs8, SImm16 is op0_4=0 & op4_8=0b0000 & acs8 & op9_16=1 & acf8; SImm16 { acs8 = acs8 + SImm16; FLAGS(acf8); }
:XORI  acm8, SImm16 is op0_4=0 & op4_8=0b0010 & acm8 & op9_16=1 & acf8; SImm16 { acm8 = acm8 ^ SImm16; FLAGS(acf8); }
:ANDI  acm8, SImm16 is op0_4=0 & op4_8=0b0100 & acm8 & op9_16=1 & acf8; SImm16 { acm8 = acm8 & SImm16; FLAGS(acf8); }
:ORI   acm8, SImm16 is op0_4=0 & op4_8=0b0110 & acm8 & op9_16=1 & acf8; SImm16 { acm8 = acm8 | SImm16; FLAGS(acf8); }
:CMPI  acf8, SImm16 is op0_4=0 & op4_8=0b1000 & acf8 & op9_16=1; SImm16 { FLAGS(acf8 - (SImm16 << 16)); }
:ANDCF acm8, SImm16 is op0_4=0 & op4_8=0b1010 & acm8 & op9_16=1; SImm16 unimpl
:ANDF  acm8, SImm16 is op0_4=0 & op4_8=0b1100 & acm8 & op9_16=1; SImm16 unimpl

:ILLR acm8, "@"^ar0_2 is ar0_2 & op2_4=0 & op4_8=1 & acm8 & op9_16=1 {
	acm8 = *:2 ar0_2;
}

# "Perform an additional operation depending on destination register"
:ADDIS acm8, SImm8 is SImm8 & acm8 & op9_16=0b0000010 unimpl
:CMPIS acm8, SImm8 is SImm8 & acm8 & op9_16=0b0000011 unimpl
:LRIS ac8_11, SImm8 is SImm8 & ac8_11 & op11_16=0b00001 {
	ac8_11 = SImm8;
}

:LOOPI Imm8 is Imm8 & op8_16=0b00010000 unimpl
:BLOOPI Imm8, Addr16 is Imm8 & op8_16=0b00010001; Addr16 unimpl

# op3_8 is marked as ????? in the table but shown as 0s for the instruction itself
# TODO: Could maybe specify what the bit is with a name
:SBSET Imm3 is Imm3 & op3_8=0 & op8_16=0b00010010 {
	sr = sr | 1 << (6 + Imm3);
}
:SBCLR Imm3 is Imm3 & op3_8=0 & op8_16=0b00010011 {
	sr = sr & ~(1 << (6 + Imm3));
}

# The manual is written such that it implies LSL/LSR and ASL/ASR are the same instruction with a 7-bit signed immediate value,
# though it treats them as 2 pairs of instructions with a 6-bit value (allegedly somehow sign-extended for the right-shift)
:LSL acf8, Imm6 is Imm6 & op6_8=0b00 & acf8 & op9_16=0b0001010 {
	acf8 = acf8 << Imm6;
}
:LSR acf8, Imm6 is Imm6 & op6_8=0b01 & acf8 & op9_16=0b0001010  {
	acf8 = acf8 >> Imm6;
}
:ASL acf8, Imm6 is Imm6 & op6_8=0b10 & acf8 & op9_16=0b0001010 {
	# This doesn't do anything different, does it?
	acf8 = acf8 << Imm6;
}
:ASR acf8, Imm6 is Imm6 & op6_8=0b11 & acf8 & op9_16=0b0001010 {
	acf8 = acf8 s>> Imm6;
}

:SI Mem8, Imm16 is Mem8 & op8_16=0b00010110; Imm16 {
	Mem8 = Imm16;
}

:CALLR reg5_8 is op0_5=0b11111 & reg5_8 & op8_16=0b00010111 {
	# TODO: Update stack
	call [reg5_8];
}
:JMPR reg5_8 is op0_5=0b01111 & reg5_8 & op8_16=0b00010111 {
	goto [reg5_8];
}

:LRR  reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b00 & op9_16=0b0001100 {
	reg0_5 = *:2 ar5_7;
	# "Perform an additional operation depending on destination register"
}
:LRRD reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b01 & op9_16=0b0001100 {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 - 1;
	# "Perform an additional operation depending on destination register"
}
:LRRI reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b10 & op9_16=0b0001100 {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 + 1;
	# "Perform an additional operation depending on destination register"
}
:LRRN reg0_5, "@"^ar5_7, ix5_7 is reg0_5 & ar5_7 & op7_9=0b11 & op9_16=0b0001100 & ix5_7 {
	reg0_5 = *:2 ar5_7;
	ar5_7 = ar5_7 + ix5_7;  # ar5_7 and ix5_7 are the same bits in the instruction.  I've included it in the disassembly, but it's not like that in the manual.
	# "Perform an additional operation depending on destination register"
}

:SRR  reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b00 & op9_16=0b0001101 {
	*:2 ar5_7 = reg0_5;
	# "Perform an additional operation depending on destination register"
}
:SRRD reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b01 & op9_16=0b0001101 {
	*:2 ar5_7 = reg0_5;
	ar5_7 = ar5_7 - 1;
	# "Perform an additional operation depending on destination register"
}
:SRRI reg0_5, "@"^ar5_7 is reg0_5 & ar5_7 & op7_9=0b10 & op9_16=0b0001101 {
	*:2 ar5_7 = reg0_5;
	ar5_7 = ar5_7 + 1;
	# "Perform an additional operation depending on destination register"
}
:SRRN reg0_5, "@"^ar5_7, ix5_7 is reg0_5 & ar5_7 & op7_9=0b11 & op9_16=0b0001101 & ix5_7 {
	*:2 ar5_7 = reg0_5;
	ar5_7 = ar5_7 + ix5_7;  # ar5_7 and ix5_7 are the same bits in the instruction.  I've included it in the disassembly, but it's not like that in the manual.
	# "Perform an additional operation depending on destination register"
}

:MRR reg5_10, reg0_5 is reg0_5 & reg5_10 & op10_16=0b000111 {
	reg5_10 = reg0_5;
}

:LRS ac8_11, Mem8 is Mem8 & ac8_11 & op11_16=0b00100 {
	ac8_11 = Mem8;
}
:SRS ac8_11, Mem8 is Mem8 & ac8_11 & op11_16=0b00101 {
	Mem8 = ac8_11;
}

# Define arithmetic opcodes and opcode parameters.
# We define them separately to match the format in the manual (OPC'EXOPC <opcode parameters> : <extended opcode parameters>).
# It would also be possible to have regular arithmetic instructions and extension instructions treated as two instructions by Ghirda,
# but that would have its own problems related to state.
# For instructions where multiple registers are handled from a single bit (e.g. aacm0 and aacf0 below), the duplicate are included
# in both bit patterns, even though it is only meaningful in the a_opp table, to make it easy to verify that both patterns are the same.
a_opc:"XORR"       is aacm0 & aaxh1 & aop2_4=0 & aop4_8=0b0011 & aacf0 {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aop2_4=0 & aop4_8=0b0011 & aacf0 {
	aacm0 = aacm0 ^ aaxh1;
	FLAGS(aacf0);
}

a_opc:"ANDR"       is aacm0 & aaxh1 & aop2_4=1 & aop4_8=0b0011 & aacf0 {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aop2_4=1 & aop4_8=0b0011 & aacf0 {
	aacm0 = aacm0 & aaxh1;
	FLAGS(aacf0);
}

a_opc:"ORR"        is aacm0 & aaxh1 & aop2_4=2 & aop4_8=0b0011 & aacf0 {}
a_opp:aacm0, aaxh1 is aacm0 & aaxh1 & aop2_4=2 & aop4_8=0b0011 & aacf0 {
	aacm0 = aacm0 | aaxh1;
	FLAGS(aacf0);
}

a_opc:"ANDC"             is aacm0 & aop1=0 & aop2_4=2 & aop4_8=0b0011 & aacm0_other & aacf0 {}
a_opp:aacm0, aacm0_other is aacm0 & aop1=0 & aop2_4=2 & aop4_8=0b0011 & aacm0_other & aacf0 {
	aacm0 = aacm0 & aacm0_other;
	FLAGS(aacf0);
}

a_opc:"ORC"              is aacm0 & aop1=1 & aop2_4=2 & aop4_8=0b0011 & aacm0_other & aacf0 {}
a_opp:aacm0, aacm0_other is aacm0 & aop1=1 & aop2_4=2 & aop4_8=0b0011 & aacm0_other & aacf0 {
	aacm0 = aacm0 | aacm0_other;
	FLAGS(aacf0);
}

a_opc:"ADDR"        is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0100 {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0100 {
	aacf0 = aacf0 + zext(aax1_2);  # TODO: Is this the right extension?
	FLAGS(aacf0);
}

a_opc:"ADDAX"      is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0100 {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0100 {
	aacf0 = aacf0 + zext(aaxf1);  # TODO: Is this the right extension?
	FLAGS(aacf0);
}

a_opc:"ADD"              is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0100 & aacf0_other {}
a_opp:aacf0, aacf0_other is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0100 & aacf0_other {
	aacf0 = aacf0 + aacf0_other;
	FLAGS(aacf0);
}

a_opc:"ADDP" is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0100 {}
a_opp:aacf0  is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0100 unimpl # TODO: Product register

a_opc:"SUBR"        is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0101 {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0101 {
	aacf0 = aacf0 - zext(aax1_2);  # TODO: Is this the right extension?
	FLAGS(aacf0);
}

a_opc:"SUBAX"      is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0101 {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0101 {
	aacf0 = aacf0 - zext(aaxf1);  # TODO: Is this the right extension?
	FLAGS(aacf0);
}

a_opc:"SUB"              is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0101 & aacf0_other {}
a_opp:aacf0, aacf0_other is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0101 & aacf0_other {
	aacf0 = aacf0 - aacf0_other;
	FLAGS(aacf0);
}

a_opc:"SUBP" is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0101 {}
a_opp:aacf0  is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0101 unimpl # TODO: Product register

a_opc:"MOVR"        is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0110 {}
a_opp:aacf0, aax1_2 is aacf0 & aax1_2 & aop3=0 & aop4_8=0b0110 {
	# high bits sign-extended, middle bits based on value, low bits zeroed
	# TODO: Use aacs0?
	aacf0 = sext(aax1_2) << 16;
	FLAGS(aacf0);
}

a_opc:"MOVAX"      is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0110 {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 & aop2_4=2 & aop4_8=0b0110 {
	aacf0 = zext(aaxf1);  # TODO: Is this the right extension?
	FLAGS(aacf0);
}

a_opc:"MOV"              is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0110 & aacf0_other {}
a_opp:aacf0, aacf0_other is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0110 & aacf0_other {
	aacf0 = aacf0_other;
	FLAGS(aacf0);
}

a_opc:"MOVP" is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0110 {}
a_opp:aacf0  is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0110 unimpl # TODO: Product register

a_opc:"ADDAXL"     is aacf0 & aaxl1 & aop2_4=0 & aop4_8=0b0111 {}
a_opp:aacf0, aaxl1 is aacf0 & aaxl1 & aop2_4=0 & aop4_8=0b0111 {
	aacf0 = aacf0 + zext(aaxl1);  # TODO: Is this the right extension?
	FLAGS(aacf0);
}

a_opc:"INCM" is aacs0 & aop1=0 & aop2_4=1 & aop4_8=0b0111 & aacf0 {}
a_opp:aacs0  is aacs0 & aop1=0 & aop2_4=1 & aop4_8=0b0111 & aacf0 {
	aacs0 = aacs0 + 1;
	FLAGS(aacf0);
}

a_opc:"INC" is aacf0 & aop1=1 & aop2_4=1 & aop4_8=0b0111 {}
a_opp:aacf0 is aacf0 & aop1=1 & aop2_4=1 & aop4_8=0b0111 {
	aacf0 = aacf0 + 1;
	FLAGS(aacf0);
}

a_opc:"DECM" is aacs0 & aop1=0 & aop2_4=2 & aop4_8=0b0111 & aacf0 {}
a_opp:aacs0  is aacs0 & aop1=0 & aop2_4=2 & aop4_8=0b0111 & aacf0 {
	aacs0 = aacs0 - 1;
	FLAGS(aacf0);
}

a_opc:"DEC" is aacf0 & aop1=1 & aop2_4=2 & aop4_8=0b0111 {}
a_opp:aacf0 is aacf0 & aop1=1 & aop2_4=2 & aop4_8=0b0111 {
	aacf0 = aacf0 - 1;
	FLAGS(aacf0);
}

a_opc:"NEG" is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0111 {}
a_opp:aacf0 is aacf0 & aop1=0 & aop2_4=3 & aop4_8=0b0111 {
	aacf0 = -aacf0;
	FLAGS(aacf0);
}

a_opc:"MOVNP" is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0111 {}
a_opp:aacf0   is aacf0 & aop1=1 & aop2_4=3 & aop4_8=0b0111 unimpl # TODO: (Negated) product register

# A NOP that is used to specify only an extended opcode.  Bit 3 can be either 0 or 1.
a_opc:"NX" is aop0_3=0 & aop4_8=0b1000 {}
a_opp:""   is aop0_3=0 & aop4_8=0b1000 {}

a_opc:"CLR" is aop0_3=1 & aacf3 & aop4_8=0b1000 {}
a_opp:aacf3 is aop0_3=1 & aacf3 & aop4_8=0b1000 {
	aacf3 = 0;
	FLAGS(aacf3);
}

a_opc:"CMP" is aop0_3=0b010 & aop3=0 & aop4_8=0b1000 {}
a_opp:""    is aop0_3=0b010 & aop3=0 & aop4_8=0b1000 {
	FLAGS(ac0 - ac1);
}

# 1000 0011 is unused

a_opc:"CLRP" is aop0_3=0b100 & aop3=0 & aop4_8=0b1000 {}
a_opp:""     is aop0_3=0b100 & aop3=0 & aop4_8=0b1000 {
	prod.l  = 0x0000;
	prod.m1 = 0xfff0;
	prod.h  = 0x00ff;
	prod.m2 = 0x0010;
}

a_opc:"TSTAXH" is aaxh0 & aop1_4=0b011 & aop4_8=0b1000 {}
a_opp:aaxh0    is aaxh0 & aop1_4=0b011 & aop4_8=0b1000 {
	FLAGS(aaxh0);
}

# TODO: These instructions are not documented in detail in the manual.
# These opcodes are based on Dolphin's DSPTables.cpp.
a_opc:"M2" is aop0_8=0b10001010 {}
a_opp:""   is aop0_8=0b10001010 unimpl

a_opc:"M0" is aop0_8=0b10001011 {}
a_opp:""   is aop0_8=0b10001011 unimpl

a_opc:"CLR15" is aop0_8=0b10001100 {}
a_opp:""      is aop0_8=0b10001100 unimpl

a_opc:"SET15" is aop0_8=0b10001101 {}
a_opp:""      is aop0_8=0b10001101 unimpl

a_opc:"SET16" is aop0_8=0b10001110 {}
a_opp:""      is aop0_8=0b10001110 unimpl

a_opc:"SET40" is aop0_8=0b10001111 {}
a_opp:""      is aop0_8=0b10001111 unimpl

# TODO: "$sr.AM bit affects multiply result"
a_opc:"MUL"        is aop0_3=0b000 & aaxl3 & aop4_8=0b1001 & aaxh3 {}
a_opp:aaxl3, aaxh3 is aop0_3=0b000 & aaxl3 & aop4_8=0b1001 & aaxh3 unimpl

a_opc:"ASR16" is aop0_3=0b001 & aacf3 & aop4_8=0b1001 {}
a_opp:aacf3   is aop0_3=0b001 & aacf3 & aop4_8=0b1001 {
	aacf3 = aacf3 s>> 16;
	FLAGS(aacf3);
}

a_opc:"MULMVZ"            is aacf0 & aop1_3=0b01 & aaxl3 & aop4_8=0b1001 & aaxh3 {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aop1_3=0b01 & aaxl3 & aop4_8=0b1001 & aaxh3 unimpl

a_opc:"MULAC"             is aacf0 & aop1_3=0b10 & aaxl3 & aop4_8=0b1001 & aaxh3 {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aop1_3=0b10 & aaxl3 & aop4_8=0b1001 & aaxh3 unimpl

a_opc:"MULMV"             is aacf0 & aop1_3=0b11 & aaxl3 & aop4_8=0b1001 & aaxh3 {}
a_opp:aaxl3, aaxh3, aacf0 is aacf0 & aop1_3=0b11 & aaxl3 & aop4_8=0b1001 & aaxh3 unimpl

a_opc:"MULX"           is aop0_3=0b000 & aax1lh3 & aax0lh4 & aop5_8=0b101 & aaxh3 {}
a_opp:aax0lh4, aax1lh3 is aop0_3=0b000 & aax1lh3 & aax0lh4 & aop5_8=0b101 & aaxh3 unimpl

# 1010r001 is marked as ???

a_opc:"MULXMVZ"               is aacf0 & aop1_3=0b01 & aax1lh3 & aax0lh4 & aop5_8=0b101 {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aop1_3=0b01 & aax1lh3 & aax0lh4 & aop5_8=0b101 unimpl

a_opc:"MULXAC"                is aacf0 & aop1_3=0b10 & aax1lh3 & aax0lh4 & aop5_8=0b101 {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aop1_3=0b10 & aax1lh3 & aax0lh4 & aop5_8=0b101 unimpl

a_opc:"MULXMV"                is aacf0 & aop1_3=0b11 & aax1lh3 & aax0lh4 & aop5_8=0b101 {}
a_opp:aax0lh4, aax1lh3, aacf0 is aacf0 & aop1_3=0b11 & aax1lh3 & aax0lh4 & aop5_8=0b101 unimpl

a_opc:"MULC"       is aop0_3=0b000 & aaxh3 & aacm4 & aop5_8=0b110 {}
a_opp:aacm4, aaxh3 is aop0_3=0b000 & aaxh3 & aacm4 & aop5_8=0b110 unimpl

# 1010r001 is marked as CMP, but it's clearly not CMP

a_opc:"MULCMVZ"           is aacf0 & aop1_3=0b01 & aaxh3 & aacm4 & aop5_8=0b110 {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aop1_3=0b01 & aaxh3 & aacm4 & aop5_8=0b110 unimpl

a_opc:"MULCAC"            is aacf0 & aop1_3=0b10 & aaxh3 & aacm4 & aop5_8=0b110 {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aop1_3=0b10 & aaxh3 & aacm4 & aop5_8=0b110 unimpl

a_opc:"MULCMV"            is aacf0 & aop1_3=0b11 & aaxh3 & aacm4 & aop5_8=0b110  {}
a_opp:aacm4, aaxh3, aacf0 is aacf0 & aop1_3=0b11 & aaxh3 & aacm4 & aop5_8=0b110 unimpl

a_opc:"MADDX"          is aax1lh0 & aax0lh1 & aop2_4=0b00 & aop4_8=0b1110 {}
a_opp:aax0lh1, aax1lh0 is aax1lh0 & aax0lh1 & aop2_4=0b00 & aop4_8=0b1110 unimpl

a_opc:"MSUBX"          is aax1lh0 & aax0lh1 & aop2_4=0b01 & aop4_8=0b1110 {}
a_opp:aax0lh1, aax1lh0 is aax1lh0 & aax0lh1 & aop2_4=0b01 & aop4_8=0b1110 unimpl

# Docs are ambiguous about if it uses acS.l or acS.m, but say to use m for MSUBC, so I assume this is a typo
a_opc:"MADDC"      is aaxh0 & aacm1 & aop2_4=0b10 & aop4_8=0b1110 {}
a_opp:aacm1, aaxh0 is aaxh0 & aacm1 & aop2_4=0b10 & aop4_8=0b1110 unimpl

a_opc:"MSUBC"      is aaxh0 & aacm1 & aop2_4=0b11 & aop4_8=0b1110 {}
a_opp:aacm1, aaxh0 is aaxh0 & aacm1 & aop2_4=0b11 & aop4_8=0b1110 unimpl

a_opc:"LSL16" is aacf0 & aop1_4=0b000 & aop4_8=0b1111 {}
a_opp:aacf0   is aacf0 & aop1_4=0b000 & aop4_8=0b1111 {
	aacf0 = aacf0 << 16;
	FLAGS(aacf0);
}

a_opc:"MADD"       is aaxl0 & aop1_4=0b001 & aop4_8=0b1111 & aaxh0 {}
a_opp:aaxl0, aaxh0 is aaxl0 & aop1_4=0b001 & aop4_8=0b1111 & aaxh0 unimpl

a_opc:"LSR16" is aacf0 & aop1_4=0b010 & aop4_8=0b1111 {}
a_opp:aacf0   is aacf0 & aop1_4=0b010 & aop4_8=0b1111 {
	aacf0 = aacf0 >> 16;
	FLAGS(aacf0);
}

a_opc:"MSUB"       is aaxl0 & aop1_4=0b011 & aop4_8=0b1111 & aaxh0 {}
a_opp:aaxl0, aaxh0 is aaxl0 & aop1_4=0b011 & aop4_8=0b1111 & aaxh0 unimpl

a_opc:"ADDPAXZ"    is aacf0 & aaxf1 & aop2_4=0b10 & aop4_8=0b1111 {}
a_opp:aacf0, aaxf1 is aacf0 & aaxf1 & aop2_4=0b10 & aop4_8=0b1111 unimpl

a_opc:"CLRL" is aacl0 & aop1_4=0b110 & aop4_8=0b1111 & aacf0 {}
a_opp:aacl0  is aacl0 & aop1_4=0b110 & aop4_8=0b1111 & aacf0 {
	aacl0 = 0;
	FLAGS(aacf0);
}

a_opc:"MOVPZ" is aacf0 & aop1_4=0b111 & aop4_8=0b1111 {}
a_opp:aacf0   is aacf0 & aop1_4=0b111 & aop4_8=0b1111 unimpl

# Define extension opcodes and opcode parameters.
# There is no extension instruction with xop2_4=0 and xop4_8=0.

ext_opc:"DR"   is xar0_2 & xop2_4=1 & xop4_8=0  {}
ext_opp:xar0_2 is xar0_2 & xop2_4=1 & xop4_8=0 { xar0_2 = xar0_2 - 1; }

ext_opc:"IR"   is xar0_2 & xop2_4=2 & xop4_8=0  {}
ext_opp:xar0_2 is xar0_2 & xop2_4=2 & xop4_8=0 { xar0_2 = xar0_2 + 1; }

# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
ext_opc:"NR"           is xar0_2 & xop2_4=3 & xop4_8=0 & xix0_2 {}
ext_opp:xar0_2, xix0_2 is xar0_2 & xop2_4=3 & xop4_8=0 & xix0_2 { xar0_2 = xar0_2 + xix0_2; }

ext_opc:"MV"           is xac0_2 & xax2_4 & xop4_8=1 {}
ext_opp:xax2_4, xac0_2 is xac0_2 & xax2_4 & xop4_8=1 { xax2_4 = xac0_2; }

ext_opc:"L"                is xar0_2 & xop2=0 & xac3_6 & xop6_8=1 {}
ext_opp:xac3_6, "@"^xar0_2 is xar0_2 & xop2=0 & xac3_6 & xop6_8=1 { xac3_6 = *:2 xar0_2; xar0_2 = xar0_2 + 1; }

# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
ext_opc:"LN"                       is xar0_2 & xix0_2 & xop2=1 & xac3_6 & xop6_8=1 {}
ext_opp:xac3_6, "@"^xar0_2, xix0_2 is xar0_2 & xix0_2 & xop2=1 & xac3_6 & xop6_8=1 { xac3_6 = *:2 xar0_2; xar0_2 = xar0_2 + xix0_2; }

# 'LN and 'LS have the same encoding in the manual
# I've assumed 01ddd1ss should instead be 10dd000s, to match the table and other 'LS variants
ext_opc:"LS"          is xacm0 & xop1=0 & xop2_4=0 & xax4_6 & xop6_8=2 {}
ext_opp:xax4_6, xacm0 is xacm0 & xop1=0 & xop2_4=0 & xax4_6 & xop6_8=2 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + 1;
}

ext_opc:"LSN"         is xacm0 & xop1=0 & xop2_4=1 & xax4_6 & xop6_8=2 {}
ext_opp:xax4_6, xacm0 is xacm0 & xop1=0 & xop2_4=1 & xax4_6 & xop6_8=2 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + 1;
}

ext_opc:"LSM"         is xacm0 & xop1=0 & xop2_4=2 & xax4_6 & xop6_8=2 {}
ext_opp:xax4_6, xacm0 is xacm0 & xop1=0 & xop2_4=2 & xax4_6 & xop6_8=2 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + ix3;
}

ext_opc:"LSNM"        is xacm0 & xop1=0 & xop2_4=3 & xax4_6 & xop6_8=2 {}
ext_opp:xax4_6, xacm0 is xacm0 & xop1=0 & xop2_4=3 & xax4_6 & xop6_8=2 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + ix3;
}

ext_opc:"S"                is xar0_2 & xop2=0 & xac3_5 & xop5=1 & xop6_8=0 {}
ext_opp:xac3_5, "@"^xar0_2 is xar0_2 & xop2=0 & xac3_5 & xop5=1 & xop6_8=0 { *:2 xar0_2 = xac3_5; xar0_2 = xar0_2 + 1; }

# xar0_2 and xix0_2 are the same bits in the instruction.  The manual doesn't show xix0_2, but I've included it in the disassembly.
ext_opc:"SN"                       is xar0_2 & xop2=1 & xac3_5 & xop5=1 & xop6_8=0 & xix0_2 {}
ext_opp:xac3_5, "@"^xar0_2, xix0_2 is xar0_2 & xop2=1 & xac3_5 & xop5=1 & xop6_8=0 & xix0_2 { *:2 xar0_2 = xac3_5; xar0_2 = xar0_2 + xix0_2; }

ext_opc:"SL"          is xacm0 & xop1=1 & xop2_4=0 & xax4_6 & xop6_8=2 {}
ext_opp:xax4_6, xacm0 is xacm0 & xop1=1 & xop2_4=0 & xax4_6 & xop6_8=2 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + 1;
}

ext_opc:"SLN"         is xacm0 & xop1=1 & xop2_4=1 & xax4_6 & xop6_8=2 {}
ext_opp:xax4_6, xacm0 is xacm0 & xop1=1 & xop2_4=1 & xax4_6 & xop6_8=2 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + 1;
}

ext_opc:"SLM"         is xacm0 & xop1=1 & xop2_4=2 & xax4_6 & xop6_8=2 {}
ext_opp:xax4_6, xacm0 is xacm0 & xop1=1 & xop2_4=2 & xax4_6 & xop6_8=2 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = xacm0;
	ar0 = ar0 + 1;
	ar3 = ar3 + ix3;
}

ext_opc:"SLNM"        is xacm0 & xop1=1 & xop2_4=3 & xax4_6 & xop6_8=2 {}
ext_opp:xax4_6, xacm0 is xacm0 & xop1=1 & xop2_4=3 & xax4_6 & xop6_8=2 {
	xax4_6 = *:2 ar0;
	*:2 ar3 = xacm0;
	ar0 = ar0 + ix0;
	ar3 = ar3 + ix3;
}

# The table mentions LD[NM|M|N] and LD2[NM|M|N] extension opcodes, but they aren't in the main manual

# Combine arithmetic ops and extension ops
:^a_opc^"'"^ext_opc a_opp ":" ext_opp is a_opc & a_opp; ext_opc & ext_opp { build a_opp; build ext_opp; }

# Although the manual doesn't mention it, if the extension opcode is set to 0, it seems like it's a NOP.
:^a_opc a_opp is a_opc & a_opp; xop0_8=0 { build a_opp; }
